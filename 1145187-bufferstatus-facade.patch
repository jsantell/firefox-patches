From: Jordan Santell <jsantell@mozilla.com>
Date: Mon, 4 May 2015 09:19:26 -0700
Subject: Bug 1145187 - Implement polling for buffer status on performance actor facades. r=vp

diff --git a/browser/devtools/performance/modules/actors.js b/browser/devtools/performance/modules/actors.js
index 61fec66..012c33c 100644
--- a/browser/devtools/performance/modules/actors.js
+++ b/browser/devtools/performance/modules/actors.js
@@ -14,24 +14,27 @@ const {
 loader.lazyRequireGetter(this, "EventEmitter",
   "devtools/toolkit/event-emitter");
 loader.lazyRequireGetter(this, "RecordingUtils",
   "devtools/performance/recording-utils", true);
 loader.lazyRequireGetter(this, "TimelineFront",
   "devtools/server/actors/timeline", true);
 loader.lazyRequireGetter(this, "MemoryFront",
   "devtools/server/actors/memory", true);
-loader.lazyRequireGetter(this, "timers",
-  "resource://gre/modules/Timer.jsm");
+loader.lazyRequireGetter(this, "Poller",
+  "devtools/shared/poller", true);
 
 // how often do we pull allocation sites from the memory actor
 const ALLOCATION_SITE_POLL_TIMER = 200; // ms
 
+// how often do we check the status of the profiler's circular buffer
+const BUFFER_CHECK_TIMER = 5000; // ms
+
 const MEMORY_ACTOR_METHODS = [
-  "destroy", "attach", "detach", "getState", "getAllocationsSettings",
+  "attach", "detach", "getState", "getAllocationsSettings",
   "getAllocations", "startRecordingAllocations", "stopRecordingAllocations"
 ];
 
 const TIMELINE_ACTOR_METHODS = [
   "start", "stop",
 ];
 
 const PROFILER_ACTOR_METHODS = [
@@ -40,89 +43,130 @@ const PROFILER_ACTOR_METHODS = [
 ];
 
 /**
  * Constructor for a facade around an underlying ProfilerFront.
  */
 function ProfilerFrontFacade (target) {
   this._target = target;
   this._onProfilerEvent = this._onProfilerEvent.bind(this);
+  this._checkBufferStatus = this._checkBufferStatus.bind(this);
+  this._BUFFER_CHECK_TIMER = this._target.TEST_MOCK_BUFFER_CHECK_TIMER || BUFFER_CHECK_TIMER;
+
   EventEmitter.decorate(this);
 }
 
 ProfilerFrontFacade.prototype = {
   EVENTS: ["console-api-profiler", "profiler-stopped"],
 
   // Connects to the targets underlying real ProfilerFront.
   connect: Task.async(function*() {
     let target = this._target;
     this._actor = yield getProfiler(target);
 
     // Fetch and store information about the SPS profiler and
     // server profiler.
     this.traits = {};
     this.traits.filterable = target.getTrait("profilerDataFilterable");
+    this.traits.bufferStatus = target.getTrait("profilerBufferStatus");
 
     // Directly register to event notifications when connected
     // to hook into `console.profile|profileEnd` calls.
     yield this.registerEventNotifications({ events: this.EVENTS });
     // TODO bug 1159389, listen directly to actor if supporting new front
     target.client.addListener("eventNotification", this._onProfilerEvent);
   }),
 
   /**
    * Unregisters events for the underlying profiler actor.
    */
   destroy: Task.async(function *() {
+    if (this._poller) {
+      yield this._poller.off();
+    }
     yield this.unregisterEventNotifications({ events: this.EVENTS });
     // TODO bug 1159389, listen directly to actor if supporting new front
     this._target.client.removeListener("eventNotification", this._onProfilerEvent);
   }),
 
   /**
    * Starts the profiler actor, if necessary.
+   *
+   * @option {number?} bufferSize
+   * @option {number?} sampleFrequency
    */
   start: Task.async(function *(options={}) {
+    // Check for poller status even if the profiler is already active --
+    // profiler can be activated via `console.profile` or another source, like
+    // the Gecko Profiler.
+    if (!this._poller) {
+      this._poller = new Poller(this._checkBufferStatus, this._BUFFER_CHECK_TIMER, false);
+    }
+    if (!this._poller.isPolling()) {
+      this._poller.on();
+    }
+
     // Start the profiler only if it wasn't already active. The built-in
     // nsIPerformance module will be kept recording, because it's the same instance
     // for all targets and interacts with the whole platform, so we don't want
     // to affect other clients by stopping (or restarting) it.
     let profilerStatus = yield this.isActive();
     if (profilerStatus.isActive) {
+      // Get the buffer status at the starting point
+      let bufferStatus = yield this.getBufferInfo();
+
       this.emit("profiler-already-active");
-      return profilerStatus.currentTime;
+      return { startTime: profilerStatus.currentTime, bufferStatus };
     }
 
     // Translate options from the recording model into profiler-specific
     // options for the nsIProfiler
     let profilerOptions = {
       entries: options.bufferSize,
       interval: options.sampleFrequency ? (1000 / (options.sampleFrequency * 1000)) : void 0
     };
 
     yield this.startProfiler(profilerOptions);
+    // Get the buffer status at the starting point
+    let bufferStatus = yield this.getBufferInfo();
 
     this.emit("profiler-activated");
-    return 0;
+    return { startTime: 0, bufferStatus };
+  }),
+
+  /**
+   * Indicates the end of a recording -- does not actually stop the profiler
+   * (stopProfiler does that), but notes that we no longer need to poll
+   * for buffer status.
+   */
+  stop: Task.async(function *() {
+    yield this._poller.off();
   }),
 
   /**
    * Returns profile data from now since `startTime`.
    */
   getProfile: Task.async(function *(options) {
     let profilerData = yield (actorCompatibilityBridge("getProfile").call(this, options));
     // If the backend does not support filtering by start and endtime on platform (< Fx40),
     // do it on the client (much slower).
     if (!this.traits.filterable) {
       RecordingUtils.filterSamples(profilerData.profile, options.startTime || 0);
     }
 
     return profilerData;
   }),
 
+  getBufferInfo: Task.async(function *() {
+    if (!this.traits.bufferStatus) {
+      return null;
+    }
+    return (yield actorCompatibilityBridge("getBufferInfo").call(this));
+  }),
+
   /**
    * Invoked whenever a registered event was emitted by the profiler actor.
    *
    * @param object response
    *        The data received from the backend.
    */
   _onProfilerEvent: function (_, { topic, subject, details }) {
     if (topic === "console-api-profiler") {
@@ -131,16 +175,20 @@ ProfilerFrontFacade.prototype = {
       } else if (subject.action === "profileEnd") {
         this.emit("console-profile-end", details);
       }
     } else if (topic === "profiler-stopped") {
       this.emit("profiler-stopped");
     }
   },
 
+  _checkBufferStatus: Task.async(function *() {
+    this.emit("buffer-status", (yield this.getBufferInfo()));
+  }),
+
   toString: () => "[object ProfilerFrontFacade]"
 };
 
 // Bind all the methods that directly proxy to the actor
 PROFILER_ACTOR_METHODS.forEach(method => ProfilerFrontFacade.prototype[method] = actorCompatibilityBridge(method));
 exports.ProfilerFront = ProfilerFrontFacade;
 
 /**
@@ -195,45 +243,61 @@ TIMELINE_ACTOR_METHODS.forEach(method => TimelineFrontFacade.prototype[method] =
 exports.TimelineFront = TimelineFrontFacade;
 
 /**
  * Constructor for a facade around an underlying ProfilerFront.
  */
 function MemoryFrontFacade (target) {
   this._target = target;
   this._pullAllocationSites = this._pullAllocationSites.bind(this);
+
   EventEmitter.decorate(this);
 }
 
 MemoryFrontFacade.prototype = {
   connect: Task.async(function*() {
     let supported = yield memoryActorSupported(this._target);
     this._actor = supported ?
                   new MemoryFront(this._target.client, this._target.form) :
                   new MockMemoryFront();
 
     this.IS_MOCK = !supported;
   }),
 
   /**
+   * Disables polling and destroys actor.
+   */
+  destroy: Task.async(function *() {
+    if (this._poller) {
+      yield this._poller.off();
+    }
+    yield this._actor.destroy();
+  }),
+
+  /**
    * Starts polling for allocation information.
    */
   start: Task.async(function *(options) {
     if (!options.withAllocations) {
       return 0;
     }
 
     yield this.attach();
 
     let startTime = yield this.startRecordingAllocations({
       probability: options.allocationsSampleProbability,
       maxLogLength: options.allocationsMaxLogLength
     });
 
-    yield this._pullAllocationSites();
+    if (!this._poller) {
+      this._poller = new Poller(this._pullAllocationSites, ALLOCATION_SITE_POLL_TIMER, false);
+    }
+    if (!this._poller.isPolling()) {
+      this._poller.on();
+    }
 
     return startTime;
   }),
 
   /**
    * Stops polling for allocation information.
    */
   stop: Task.async(function *(options) {
@@ -241,18 +305,18 @@ MemoryFrontFacade.prototype = {
       return 0;
     }
 
     // Since `_pullAllocationSites` is usually running inside a timeout, and
     // it's performing asynchronous requests to the server, a recording may
     // be stopped before that method finishes executing. Therefore, we need to
     // wait for the last request to `getAllocations` to finish before actually
     // stopping recording allocations.
+    yield this._poller.off();
     yield this._lastPullAllocationSitesFinished;
-    timers.clearTimeout(this._sitesPullTimeout);
 
     let endTime = yield this.stopRecordingAllocations();
     yield this.detach();
 
     return endTime;
   }),
 
   /**
@@ -275,18 +339,16 @@ MemoryFrontFacade.prototype = {
     // being the event name, and the second argument describing the type.
     this.emit("timeline-data", "allocations", {
       sites: memoryData.allocations,
       timestamps: memoryData.allocationsTimestamps,
       frames: memoryData.frames,
       counts: memoryData.counts
     });
 
-    this._sitesPullTimeout = timers.setTimeout(this._pullAllocationSites, ALLOCATION_SITE_POLL_TIMER);
-
     resolve();
   }),
 
   toString: () => "[object MemoryFrontFacade]"
 };
 
 // Bind all the methods that directly proxy to the actor
 MEMORY_ACTOR_METHODS.forEach(method => MemoryFrontFacade.prototype[method] = actorCompatibilityBridge(method));
diff --git a/browser/devtools/performance/modules/compatibility.js b/browser/devtools/performance/modules/compatibility.js
index fd79287..b34e77b 100644
--- a/browser/devtools/performance/modules/compatibility.js
+++ b/browser/devtools/performance/modules/compatibility.js
@@ -148,16 +148,23 @@ function legacyRequest (target, actor, method, args) {
 /**
  * Returns a function to be used as a method on an "Actor" in ./actors.
  * Calls the underlying actor's method, supporting the modern `Front`
  * interface if possible, otherwise, falling back to using
  * `legacyRequest`.
  */
 function actorCompatibilityBridge (method) {
   return function () {
+    // If there's no target or client on this actor facade,
+    // abort silently -- this occurs in tests when polling occurs
+    // after the test ends, when tests do not wait for toolbox destruction
+    // (which will destroy the actor facade, turning off the polling).
+    if (!this._target || !this._target.client) {
+      return;
+    }
     // Check to see if this is a modern ActorFront, which has its
     // own `request` method. Also, check if its a mock actor, as it mimicks
     // the ActorFront interface.
     // The profiler actor does not currently support the modern `Front`
     // interface, so we have to manually push packets to it.
     // TODO bug 1159389, fix up profiler actor to not need this, however
     // we will need it for backwards compat
     if (this.IS_MOCK || this._actor.request) {
diff --git a/browser/devtools/performance/modules/front.js b/browser/devtools/performance/modules/front.js
index 0ce6e83..56c8fbc 100644
--- a/browser/devtools/performance/modules/front.js
+++ b/browser/devtools/performance/modules/front.js
@@ -16,25 +16,21 @@ loader.lazyRequireGetter(this, "DevToolsUtils",
 loader.lazyRequireGetter(this, "actors",
   "devtools/performance/actors");
 
 loader.lazyImporter(this, "gDevTools",
   "resource:///modules/devtools/gDevTools.jsm");
 loader.lazyImporter(this, "Promise",
   "resource://gre/modules/Promise.jsm");
 
-
-// How often do we pull allocation sites from the memory actor.
-const DEFAULT_ALLOCATION_SITES_PULL_TIMEOUT = 200; // ms
-
 // Events to pipe from PerformanceActorsConnection to the PerformanceFront
 const CONNECTION_PIPE_EVENTS = [
   "console-profile-start", "console-profile-ending", "console-profile-end",
   "timeline-data", "profiler-already-active", "profiler-activated",
-  "recording-started", "recording-stopped"
+  "recording-started", "recording-stopped", "buffer-status"
 ];
 
 /**
  * A cache of all PerformanceActorsConnection instances.
  * The keys are Target objects.
  */
 let SharedPerformanceActors = new WeakMap();
 
@@ -75,16 +71,17 @@ function PerformanceActorsConnection(target) {
   this._pendingConsoleRecordings = [];
   this._sitesPullTimeout = 0;
   this._recordings = [];
 
   this._pipeToConnection = this._pipeToConnection.bind(this);
   this._onTimelineData = this._onTimelineData.bind(this);
   this._onConsoleProfileStart = this._onConsoleProfileStart.bind(this);
   this._onConsoleProfileEnd = this._onConsoleProfileEnd.bind(this);
+  this._onBufferStatus = this._onBufferStatus.bind(this);
   this._onProfilerUnexpectedlyStopped = this._onProfilerUnexpectedlyStopped.bind(this);
 
   Services.obs.notifyObservers(null, "performance-actors-connection-created", null);
 }
 
 PerformanceActorsConnection.prototype = {
 
   // Properties set based off of server actor support
@@ -169,29 +166,31 @@ PerformanceActorsConnection.prototype = {
   _registerListeners: function () {
     this._timeline.on("timeline-data", this._onTimelineData);
     this._memory.on("timeline-data", this._onTimelineData);
     this._profiler.on("console-profile-start", this._onConsoleProfileStart);
     this._profiler.on("console-profile-end", this._onConsoleProfileEnd);
     this._profiler.on("profiler-stopped", this._onProfilerUnexpectedlyStopped);
     this._profiler.on("profiler-already-active", this._pipeToConnection);
     this._profiler.on("profiler-activated", this._pipeToConnection);
+    this._profiler.on("buffer-status", this._onBufferStatus);
   },
 
   /**
    * Unregisters listeners on events on the underlying actors.
    */
   _unregisterListeners: function () {
     this._timeline.off("timeline-data", this._onTimelineData);
     this._memory.off("timeline-data", this._onTimelineData);
     this._profiler.off("console-profile-start", this._onConsoleProfileStart);
     this._profiler.off("console-profile-end", this._onConsoleProfileEnd);
     this._profiler.off("profiler-stopped", this._onProfilerUnexpectedlyStopped);
     this._profiler.off("profiler-already-active", this._pipeToConnection);
     this._profiler.off("profiler-activated", this._pipeToConnection);
+    this._profiler.off("buffer-status", this._onBufferStatus);
   },
 
   /**
    * Closes the connections to non-profiler actors.
    */
   _disconnectActors: Task.async(function* () {
     yield Promise.all([
       this._profiler.destroy(),
@@ -289,44 +288,52 @@ PerformanceActorsConnection.prototype = {
    * - frames
    * - memory
    * - ticks
    * - allocations
    *
    * Populate our internal store of recordings for all currently recording sessions.
    */
   _onTimelineData: function (_, ...data) {
-    this._recordings.forEach(e => e.addTimelineData.apply(e, data));
+    this._recordings.forEach(e => e._addTimelineData.apply(e, data));
     this.emit("timeline-data", ...data);
   },
 
   /**
+   * Called whenever the underlying profiler polls its buffer status.
+   */
+  _onBufferStatus: function (_, data) {
+    this._recordings.forEach(e => e._addBufferStatusData.call(e, data));
+    this.emit("buffer-status", data);
+  },
+
+  /**
    * Begins a recording session
    *
    * @param object options
    *        An options object to pass to the actors. Supported properties are
    *        `withTicks`, `withMemory` and `withAllocations`, `probability`, and `maxLogLength`.
    * @return object
    *         A promise that is resolved once recording has started.
    */
   startRecording: Task.async(function*(options = {}) {
     let model = new RecordingModel(options);
     // All actors are started asynchronously over the remote debugging protocol.
     // Get the corresponding start times from each one of them.
     // The timeline and memory actors are target-dependent, so start those as well,
     // even though these are mocked in older Geckos (FF < 35)
-    let profilerStartTime = yield this._profiler.start(options);
+    let { startTime: profilerStartTime, bufferStatus } = yield this._profiler.start(options);
     let timelineStartTime = yield this._timeline.start(options);
     let memoryStartTime = yield this._memory.start(options);
 
-    let data = { profilerStartTime, timelineStartTime, memoryStartTime };
+    let data = { profilerStartTime, timelineStartTime, memoryStartTime, bufferStatus };
 
     // Signify to the model that the recording has started,
     // populate with data and store the recording model here.
-    model.populate(data);
+    model._populate(data);
     this._recordings.push(model);
 
     this.emit("recording-started", model);
     return model;
   }),
 
   /**
    * Manually ends the recording session for the corresponding RecordingModel.
@@ -359,16 +366,17 @@ PerformanceActorsConnection.prototype = {
     let memoryEndTime = Date.now();
     let timelineEndTime = Date.now();
 
     // Only if there are no more sessions recording do we stop
     // the underlying memory and timeline actors. If we're still recording,
     // juse use Date.now() for the memory and timeline end times, as those
     // are only used in tests.
     if (!this.isRecording()) {
+      yield this._profiler.stop();
       memoryEndTime = yield this._memory.stop(config);
       timelineEndTime = yield this._timeline.stop(config);
     }
 
     // Set the results on the RecordingModel itself.
     model._onStopRecording({
       // Data available only at the end of a recording.
       profile: profilerData.profile,
diff --git a/browser/devtools/performance/modules/recording-model.js b/browser/devtools/performance/modules/recording-model.js
index 6d92bc9..a9f92b1 100644
--- a/browser/devtools/performance/modules/recording-model.js
+++ b/browser/devtools/performance/modules/recording-model.js
@@ -37,16 +37,18 @@ RecordingModel.prototype = {
   // Private fields, only needed when a recording is started or stopped.
   _console: false,
   _imported: false,
   _recording: false,
   _profilerStartTime: 0,
   _timelineStartTime: 0,
   _memoryStartTime: 0,
   _configuration: {},
+  _originalBufferStatus: null,
+  _bufferPercent: null,
 
   // Serializable fields, necessary and sufficient for import and export.
   _label: "",
   _duration: 0,
   _markers: null,
   _frames: null,
   _memory: null,
   _ticks: null,
@@ -84,26 +86,27 @@ RecordingModel.prototype = {
     let recordingData = this.getAllData();
     yield PerformanceIO.saveRecordingToFile(recordingData, file);
   }),
 
   /**
    * Sets up the instance with data from the SharedPerformanceConnection when
    * starting a recording. Should only be called by SharedPerformanceConnection.
    */
-  populate: function (info) {
+  _populate: function (info) {
     // Times must come from the actor in order to be self-consistent.
     // However, we also want to update the view with the elapsed time
     // even when the actor is not generating data. To do this we get
     // the local time and use it to compute a reasonable elapsed time.
     this._localStartTime = Date.now()
 
     this._profilerStartTime = info.profilerStartTime;
     this._timelineStartTime = info.timelineStartTime;
     this._memoryStartTime = info.memoryStartTime;
+    this._originalBufferStatus = info.bufferStatus;
     this._recording = true;
 
     this._markers = [];
     this._frames = [];
     this._memory = [];
     this._ticks = [];
     this._allocations = { sites: [], timestamps: [], frames: [], counts: [] };
   },
@@ -252,19 +255,45 @@ RecordingModel.prototype = {
    * Returns a boolean indicating whether or not this recording model
    * is recording.
    */
   isRecording: function () {
     return this._recording;
   },
 
   /**
+   * Returns the percent (value between 0 and 1) of buffer used in this
+   * recording. Returns `null` for recordings that are no longer recording.
+   */
+  getBufferUsage: function () {
+    return this.isRecording() ? this._bufferPercent : null;
+  },
+
+  /**
+   * Fired whenever the PerformanceFront has new buffer data.
+   */
+  _addBufferStatusData: function (bufferStatus) {
+    // If this model isn't currently recording, or if the server does not
+    // support buffer status (or if this fires after actors are being destroyed),
+    // ignore this information.
+    if (!bufferStatus || !this.isRecording()) {
+      return;
+    }
+    let { position: currentPosition, totalSize, generation: currentGeneration } = bufferStatus;
+    let { position: origPosition, generation: origGeneration } = this._originalBufferStatus;
+
+    let normalizedCurrent = (totalSize * (currentGeneration - origGeneration)) + currentPosition;
+    let percent = (normalizedCurrent - origPosition) / totalSize;
+    this._bufferPercent = percent > 1 ? 1 : percent;
+  },
+
+  /**
    * Fired whenever the PerformanceFront emits markers, memory or ticks.
    */
-  addTimelineData: function (eventName, ...data) {
+  _addTimelineData: function (eventName, ...data) {
     // If this model isn't currently recording,
     // ignore the timeline data.
     if (!this._recording) {
       return;
     }
 
     let config = this.getConfiguration();
 
@@ -314,12 +343,14 @@ RecordingModel.prototype = {
         RecordingUtils.offsetAndScaleTimestamps(timestamps, timeOffset, timeScale);
         Array.prototype.push.apply(this._allocations.sites, sites);
         Array.prototype.push.apply(this._allocations.timestamps, timestamps);
         Array.prototype.push.apply(this._allocations.frames, frames);
         Array.prototype.push.apply(this._allocations.counts, counts);
         break;
       }
     }
-  }
+  },
+
+  toString: () => "[object RecordingModel]"
 };
 
 exports.RecordingModel = RecordingModel;
diff --git a/browser/devtools/performance/test/browser.ini b/browser/devtools/performance/test/browser.ini
index e6d160b..6f0687d 100644
--- a/browser/devtools/performance/test/browser.ini
+++ b/browser/devtools/performance/test/browser.ini
@@ -14,16 +14,17 @@ support-files =
 [browser_markers-gc.js]
 [browser_markers-parse-html.js]
 [browser_perf-allocations-to-samples.js]
 [browser_perf-compatibility-01.js]
 [browser_perf-compatibility-02.js]
 [browser_perf-compatibility-03.js]
 [browser_perf-compatibility-04.js]
 [browser_perf-compatibility-05.js]
+[browser_perf-compatibility-06.js]
 [browser_perf-clear-01.js]
 [browser_perf-clear-02.js]
 [browser_perf-columns-js-calltree.js]
 [browser_perf-columns-memory-calltree.js]
 [browser_perf-console-record-01.js]
 [browser_perf-console-record-02.js]
 [browser_perf-console-record-03.js]
 [browser_perf-console-record-04.js]
@@ -84,16 +85,17 @@ support-files =
 [browser_perf-overview-selection-02.js]
 [browser_perf-overview-selection-03.js]
 [browser_perf-overview-time-interval.js]
 [browser_perf-shared-connection-02.js]
 [browser_perf-shared-connection-03.js]
 [browser_perf-states.js]
 [browser_perf-refresh.js]
 [browser_perf-ui-recording.js]
+[browser_perf-recording-model-02.js]
 [browser_perf-recording-notices-01.js]
 [browser_perf-recording-notices-02.js]
 [browser_perf_recordings-io-01.js]
 [browser_perf_recordings-io-02.js]
 [browser_perf_recordings-io-03.js]
 [browser_perf_recordings-io-04.js]
 [browser_perf-range-changed-render.js]
 [browser_perf-recording-selected-01.js]
diff --git a/browser/devtools/performance/test/browser_perf-compatibility-06.js b/browser/devtools/performance/test/browser_perf-compatibility-06.js
new file mode 100644
index 0000000..bb9b325
--- /dev/null
+++ b/browser/devtools/performance/test/browser_perf-compatibility-06.js
@@ -0,0 +1,32 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+/**
+ * Tests that when using an older server (< Fx40) where the profiler actor does not
+ * have the `getBufferInfo` method that nothing breaks and RecordingModels have null
+ * `getBufferUsage()` values.
+ */
+
+function spawnTest () {
+  let { target, front } = yield initBackend(SIMPLE_URL, { TEST_MOCK_BUFFER_CHECK_TIMER: 10 });
+
+  // Explicitly override the profiler's trait `bufferStatus`
+  front._connection._profiler.traits.bufferStatus = false;
+
+  let model = yield front.startRecording();
+  let [_, stats] = yield onceSpread(front, "buffer-status");
+  is(stats, null, "buffer-status events should emit `null`");
+
+  let count = 0;
+  while (count < 5) {
+    yield once(front, "buffer-status");
+    count++;
+  }
+
+  is(model.getBufferUsage(), null, "model should have `null` for its buffer usage");
+  yield front.stopRecording(model);
+  is(model.getBufferUsage(), null, "after recording, model should still have `null` for its buffer usage");
+
+  yield removeTab(target.tab);
+  finish();
+}
diff --git a/browser/devtools/performance/test/browser_perf-recording-model-02.js b/browser/devtools/performance/test/browser_perf-recording-model-02.js
new file mode 100644
index 0000000..4749a54
--- /dev/null
+++ b/browser/devtools/performance/test/browser_perf-recording-model-02.js
@@ -0,0 +1,41 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+/**
+ * Test that buffer status is correctly updated in recording models.
+ */
+
+let BUFFER_SIZE = 20000;
+
+function spawnTest () {
+  let { target, front } = yield initBackend(SIMPLE_URL, { TEST_MOCK_BUFFER_CHECK_TIMER: 10 });
+  let config = { bufferSize: BUFFER_SIZE };
+
+  let model = yield front.startRecording(config);
+  let [_, stats] = yield onceSpread(front, "buffer-status");
+  is(stats.totalSize, BUFFER_SIZE, `buffer-status event has correct totalSize: ${stats.totalSize}`);
+  ok(stats.position < BUFFER_SIZE, `buffer-status event has correct position: ${stats.position}`);
+  is(stats.generation, 0, `buffer-status event has correct generation: ${stats.generation}`);
+
+  // Halt once more for a buffer status to ensure we're beyond 0
+  yield once(front, "buffer-status");
+
+  let lastBufferStatus = 0;
+  let checkCount = 0;
+  while (lastBufferStatus < 1) {
+    let currentBufferStatus = model.getBufferUsage();
+    ok(currentBufferStatus > lastBufferStatus, `buffer is more filled than before: ${currentBufferStatus}`);
+    lastBufferStatus = currentBufferStatus;
+    checkCount++;
+    yield once(front, "buffer-status");
+  }
+
+  ok(checkCount > 2, "atleast 3 events were fired until the buffer was filled");
+  is(lastBufferStatus, 1, "buffer usage cannot surpass 100%");
+  yield front.stopRecording(model);
+
+  is(model.getBufferUsage(), null, "getBufferUsage() should be null when no longer recording.");
+
+  yield removeTab(target.tab);
+  finish();
+}
diff --git a/browser/devtools/performance/test/head.js b/browser/devtools/performance/test/head.js
index 871d2b1..ec0032a 100644
--- a/browser/devtools/performance/test/head.js
+++ b/browser/devtools/performance/test/head.js
@@ -189,16 +189,17 @@ function initBackend(aUrl, targetOps={}) {
 
     yield target.makeRemote();
 
     // Attach addition options to `target`. This is used to force mock fronts
     // to smokescreen test different servers where memory or timeline actors
     // may not exist. Possible options that will actually work:
     // TEST_MOCK_MEMORY_ACTOR = true
     // TEST_MOCK_TIMELINE_ACTOR = true
+    // TEST_MOCK_BUFFER_CHECK_TIMER = number
     merge(target, targetOps);
 
     let connection = getPerformanceActorsConnection(target);
     yield connection.open();
 
     let front = new PerformanceFront(connection);
     return { target, front };
   });
-- 
2.2.1

