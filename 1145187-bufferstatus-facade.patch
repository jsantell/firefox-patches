From: Jordan Santell <jsantell@mozilla.com>
Date: Tue, 5 May 2015 17:12:49 -0700
Subject: Bug 1145187 - Implement polling for buffer status on performance actor facades. r=vp

diff --git a/browser/devtools/performance/modules/actors.js b/browser/devtools/performance/modules/actors.js
index 26fd96f..1696a6f 100644
--- a/browser/devtools/performance/modules/actors.js
+++ b/browser/devtools/performance/modules/actors.js
@@ -14,24 +14,27 @@ const {
 loader.lazyRequireGetter(this, "EventEmitter",
   "devtools/toolkit/event-emitter");
 loader.lazyRequireGetter(this, "RecordingUtils",
   "devtools/performance/recording-utils", true);
 loader.lazyRequireGetter(this, "TimelineFront",
   "devtools/server/actors/timeline", true);
 loader.lazyRequireGetter(this, "MemoryFront",
   "devtools/server/actors/memory", true);
-loader.lazyRequireGetter(this, "timers",
-  "resource://gre/modules/Timer.jsm");
+loader.lazyRequireGetter(this, "Poller",
+  "devtools/shared/poller", true);
 
 // how often do we pull allocation sites from the memory actor
 const ALLOCATION_SITE_POLL_TIMER = 200; // ms
 
+// how often do we check the status of the profiler's circular buffer
+const BUFFER_CHECK_TIMER = 5000; // ms
+
 const MEMORY_ACTOR_METHODS = [
-  "destroy", "attach", "detach", "getState", "getAllocationsSettings",
+  "attach", "detach", "getState", "getAllocationsSettings",
   "getAllocations", "startRecordingAllocations", "stopRecordingAllocations"
 ];
 
 const TIMELINE_ACTOR_METHODS = [
   "start", "stop",
 ];
 
 const PROFILER_ACTOR_METHODS = [
@@ -40,16 +43,19 @@ const PROFILER_ACTOR_METHODS = [
 ];
 
 /**
  * Constructor for a facade around an underlying ProfilerFront.
  */
 function ProfilerFrontFacade (target) {
   this._target = target;
   this._onProfilerEvent = this._onProfilerEvent.bind(this);
+  this._checkBufferStatus = this._checkBufferStatus.bind(this);
+  this._BUFFER_CHECK_TIMER = this._target.TEST_MOCK_BUFFER_CHECK_TIMER || BUFFER_CHECK_TIMER;
+
   EventEmitter.decorate(this);
 }
 
 ProfilerFrontFacade.prototype = {
   EVENTS: ["console-api-profiler", "profiler-stopped"],
 
   // Connects to the targets underlying real ProfilerFront.
   connect: Task.async(function*() {
@@ -67,46 +73,71 @@ ProfilerFrontFacade.prototype = {
     // TODO bug 1159389, listen directly to actor if supporting new front
     target.client.addListener("eventNotification", this._onProfilerEvent);
   }),
 
   /**
    * Unregisters events for the underlying profiler actor.
    */
   destroy: Task.async(function *() {
+    if (this._poller) {
+      yield this._poller.destroy();
+    }
     yield this.unregisterEventNotifications({ events: this.EVENTS });
     // TODO bug 1159389, listen directly to actor if supporting new front
     this._target.client.removeListener("eventNotification", this._onProfilerEvent);
   }),
 
   /**
    * Starts the profiler actor, if necessary.
+   *
+   * @option {number?} bufferSize
+   * @option {number?} sampleFrequency
    */
   start: Task.async(function *(options={}) {
+    // Check for poller status even if the profiler is already active --
+    // profiler can be activated via `console.profile` or another source, like
+    // the Gecko Profiler.
+    if (!this._poller) {
+      this._poller = new Poller(this._checkBufferStatus, this._BUFFER_CHECK_TIMER, false);
+    }
+    if (!this._poller.isPolling()) {
+      this._poller.on();
+    }
+
     // Start the profiler only if it wasn't already active. The built-in
     // nsIPerformance module will be kept recording, because it's the same instance
     // for all targets and interacts with the whole platform, so we don't want
     // to affect other clients by stopping (or restarting) it.
-    let profilerStatus = yield this.isActive();
-    if (profilerStatus.isActive) {
+    let { isActive, currentTime, position, generation, totalSize } = yield this.isActive();
+    if (isActive) {
       this.emit("profiler-already-active");
-      return profilerStatus.currentTime;
+      return { startTime: currentTime, position, generation, totalSize };
     }
 
     // Translate options from the recording model into profiler-specific
     // options for the nsIProfiler
     let profilerOptions = {
       entries: options.bufferSize,
       interval: options.sampleFrequency ? (1000 / (options.sampleFrequency * 1000)) : void 0
     };
 
     yield this.startProfiler(profilerOptions);
 
     this.emit("profiler-activated");
-    return 0;
+    return { startTime: 0, position, generation, totalSize };
+  }),
+
+  /**
+   * Indicates the end of a recording -- does not actually stop the profiler
+   * (stopProfiler does that), but notes that we no longer need to poll
+   * for buffer status.
+   */
+  stop: Task.async(function *() {
+    yield this._poller.off();
   }),
 
   /**
    * Returns profile data from now since `startTime`.
    */
   getProfile: Task.async(function *(options) {
     let profilerData = yield (actorCompatibilityBridge("getProfile").call(this, options));
     // If the backend does not support filtering by start and endtime on platform (< Fx40),
@@ -131,16 +162,20 @@ ProfilerFrontFacade.prototype = {
       } else if (subject.action === "profileEnd") {
         this.emit("console-profile-end", details);
       }
     } else if (topic === "profiler-stopped") {
       this.emit("profiler-stopped");
     }
   },
 
+  _checkBufferStatus: Task.async(function *() {
+    this.emit("buffer-status", (yield this.isActive()));
+  }),
+
   toString: () => "[object ProfilerFrontFacade]"
 };
 
 // Bind all the methods that directly proxy to the actor
 PROFILER_ACTOR_METHODS.forEach(method => ProfilerFrontFacade.prototype[method] = actorCompatibilityBridge(method));
 exports.ProfilerFront = ProfilerFrontFacade;
 
 /**
@@ -195,30 +230,41 @@ TIMELINE_ACTOR_METHODS.forEach(method => TimelineFrontFacade.prototype[method] =
 exports.TimelineFront = TimelineFrontFacade;
 
 /**
  * Constructor for a facade around an underlying ProfilerFront.
  */
 function MemoryFrontFacade (target) {
   this._target = target;
   this._pullAllocationSites = this._pullAllocationSites.bind(this);
+
   EventEmitter.decorate(this);
 }
 
 MemoryFrontFacade.prototype = {
   connect: Task.async(function*() {
     let supported = yield memoryActorSupported(this._target);
     this._actor = supported ?
                   new MemoryFront(this._target.client, this._target.form) :
                   new MockMemoryFront();
 
     this.IS_MOCK = !supported;
   }),
 
   /**
+   * Disables polling and destroys actor.
+   */
+  destroy: Task.async(function *() {
+    if (this._poller) {
+      yield this._poller.destroy();
+    }
+    yield this._actor.destroy();
+  }),
+
+  /**
    * Starts polling for allocation information.
    */
   start: Task.async(function *(options) {
     if (!options.withAllocations) {
       return 0;
     }
 
     yield this.attach();
@@ -230,17 +276,22 @@ MemoryFrontFacade.prototype = {
       allocationOptions.probability = options.allocationsSampleProbability;
     }
     if (options.allocationsMaxLogLength !== void 0) {
       allocationOptions.maxLogLength = options.allocationsMaxLogLength;
     }
 
     let startTime = yield this.startRecordingAllocations(allocationOptions);
 
-    yield this._pullAllocationSites();
+    if (!this._poller) {
+      this._poller = new Poller(this._pullAllocationSites, ALLOCATION_SITE_POLL_TIMER, false);
+    }
+    if (!this._poller.isPolling()) {
+      this._poller.on();
+    }
 
     return startTime;
   }),
 
   /**
    * Stops polling for allocation information.
    */
   stop: Task.async(function *(options) {
@@ -248,18 +299,18 @@ MemoryFrontFacade.prototype = {
       return 0;
     }
 
     // Since `_pullAllocationSites` is usually running inside a timeout, and
     // it's performing asynchronous requests to the server, a recording may
     // be stopped before that method finishes executing. Therefore, we need to
     // wait for the last request to `getAllocations` to finish before actually
     // stopping recording allocations.
+    yield this._poller.off();
     yield this._lastPullAllocationSitesFinished;
-    timers.clearTimeout(this._sitesPullTimeout);
 
     let endTime = yield this.stopRecordingAllocations();
     yield this.detach();
 
     return endTime;
   }),
 
   /**
@@ -282,18 +333,16 @@ MemoryFrontFacade.prototype = {
     // being the event name, and the second argument describing the type.
     this.emit("timeline-data", "allocations", {
       sites: memoryData.allocations,
       timestamps: memoryData.allocationsTimestamps,
       frames: memoryData.frames,
       counts: memoryData.counts
     });
 
-    this._sitesPullTimeout = timers.setTimeout(this._pullAllocationSites, ALLOCATION_SITE_POLL_TIMER);
-
     resolve();
   }),
 
   toString: () => "[object MemoryFrontFacade]"
 };
 
 // Bind all the methods that directly proxy to the actor
 MEMORY_ACTOR_METHODS.forEach(method => MemoryFrontFacade.prototype[method] = actorCompatibilityBridge(method));
diff --git a/browser/devtools/performance/modules/compatibility.js b/browser/devtools/performance/modules/compatibility.js
index fd79287..b34e77b 100644
--- a/browser/devtools/performance/modules/compatibility.js
+++ b/browser/devtools/performance/modules/compatibility.js
@@ -148,16 +148,23 @@ function legacyRequest (target, actor, method, args) {
 /**
  * Returns a function to be used as a method on an "Actor" in ./actors.
  * Calls the underlying actor's method, supporting the modern `Front`
  * interface if possible, otherwise, falling back to using
  * `legacyRequest`.
  */
 function actorCompatibilityBridge (method) {
   return function () {
+    // If there's no target or client on this actor facade,
+    // abort silently -- this occurs in tests when polling occurs
+    // after the test ends, when tests do not wait for toolbox destruction
+    // (which will destroy the actor facade, turning off the polling).
+    if (!this._target || !this._target.client) {
+      return;
+    }
     // Check to see if this is a modern ActorFront, which has its
     // own `request` method. Also, check if its a mock actor, as it mimicks
     // the ActorFront interface.
     // The profiler actor does not currently support the modern `Front`
     // interface, so we have to manually push packets to it.
     // TODO bug 1159389, fix up profiler actor to not need this, however
     // we will need it for backwards compat
     if (this.IS_MOCK || this._actor.request) {
diff --git a/browser/devtools/performance/modules/front.js b/browser/devtools/performance/modules/front.js
index 73a5a67..4048caa 100644
--- a/browser/devtools/performance/modules/front.js
+++ b/browser/devtools/performance/modules/front.js
@@ -16,24 +16,21 @@ loader.lazyRequireGetter(this, "DevToolsUtils",
 loader.lazyRequireGetter(this, "actors",
   "devtools/performance/actors");
 
 loader.lazyImporter(this, "gDevTools",
   "resource:///modules/devtools/gDevTools.jsm");
 loader.lazyImporter(this, "Promise",
   "resource://gre/modules/Promise.jsm");
 
-
-// How often do we pull allocation sites from the memory actor.
-const DEFAULT_ALLOCATION_SITES_PULL_TIMEOUT = 200; // ms
-
 // Events to pipe from PerformanceActorsConnection to the PerformanceFront
 const CONNECTION_PIPE_EVENTS = [
   "timeline-data", "profiler-already-active", "profiler-activated",
-  "recording-starting", "recording-started", "recording-stopping", "recording-stopped"
+  "recording-starting", "recording-started", "recording-stopping", "recording-stopped",
+  "buffer-status"
 ];
 
 /**
  * A cache of all PerformanceActorsConnection instances.
  * The keys are Target objects.
  */
 let SharedPerformanceActors = new WeakMap();
 
@@ -74,16 +71,17 @@ function PerformanceActorsConnection(target) {
   this._pendingConsoleRecordings = [];
   this._sitesPullTimeout = 0;
   this._recordings = [];
 
   this._pipeToConnection = this._pipeToConnection.bind(this);
   this._onTimelineData = this._onTimelineData.bind(this);
   this._onConsoleProfileStart = this._onConsoleProfileStart.bind(this);
   this._onConsoleProfileEnd = this._onConsoleProfileEnd.bind(this);
+  this._onBufferStatus = this._onBufferStatus.bind(this);
   this._onProfilerUnexpectedlyStopped = this._onProfilerUnexpectedlyStopped.bind(this);
 
   Services.obs.notifyObservers(null, "performance-actors-connection-created", null);
 }
 
 PerformanceActorsConnection.prototype = {
 
   // Properties set based off of server actor support
@@ -168,29 +166,31 @@ PerformanceActorsConnection.prototype = {
   _registerListeners: function () {
     this._timeline.on("timeline-data", this._onTimelineData);
     this._memory.on("timeline-data", this._onTimelineData);
     this._profiler.on("console-profile-start", this._onConsoleProfileStart);
     this._profiler.on("console-profile-end", this._onConsoleProfileEnd);
     this._profiler.on("profiler-stopped", this._onProfilerUnexpectedlyStopped);
     this._profiler.on("profiler-already-active", this._pipeToConnection);
     this._profiler.on("profiler-activated", this._pipeToConnection);
+    this._profiler.on("buffer-status", this._onBufferStatus);
   },
 
   /**
    * Unregisters listeners on events on the underlying actors.
    */
   _unregisterListeners: function () {
     this._timeline.off("timeline-data", this._onTimelineData);
     this._memory.off("timeline-data", this._onTimelineData);
     this._profiler.off("console-profile-start", this._onConsoleProfileStart);
     this._profiler.off("console-profile-end", this._onConsoleProfileEnd);
     this._profiler.off("profiler-stopped", this._onProfilerUnexpectedlyStopped);
     this._profiler.off("profiler-already-active", this._pipeToConnection);
     this._profiler.off("profiler-activated", this._pipeToConnection);
+    this._profiler.off("buffer-status", this._onBufferStatus);
   },
 
   /**
    * Closes the connections to non-profiler actors.
    */
   _disconnectActors: Task.async(function* () {
     yield Promise.all([
       this._profiler.destroy(),
@@ -284,46 +284,64 @@ PerformanceActorsConnection.prototype = {
    * - frames
    * - memory
    * - ticks
    * - allocations
    *
    * Populate our internal store of recordings for all currently recording sessions.
    */
   _onTimelineData: function (_, ...data) {
-    this._recordings.forEach(e => e.addTimelineData.apply(e, data));
+    this._recordings.forEach(e => e._addTimelineData.apply(e, data));
     this.emit("timeline-data", ...data);
   },
 
   /**
+   * Called whenever the underlying profiler polls its buffer status.
+   */
+  _onBufferStatus: function (_, data) {
+    // If no buffer data emitted (whether from an older actor being destroyed
+    // from a previous test, or the server does not support it), just ignore.
+    // Also check for a value of buffer status (`position`) to see if it's
+    // because of an unsupported server.
+    if (!data || data.position === void 0) {
+      return;
+    }
+    this._recordings.forEach(e => e._addBufferStatusData.call(e, data));
+    this.emit("buffer-status", data);
+  },
+
+  /**
    * Begins a recording session
    *
    * @param object options
    *        An options object to pass to the actors. Supported properties are
    *        `withTicks`, `withMemory` and `withAllocations`, `probability`, and `maxLogLength`.
    * @return object
    *         A promise that is resolved once recording has started.
    */
   startRecording: Task.async(function*(options = {}) {
     let model = new RecordingModel(options);
     this.emit("recording-starting", model);
 
     // All actors are started asynchronously over the remote debugging protocol.
     // Get the corresponding start times from each one of them.
     // The timeline and memory actors are target-dependent, so start those as well,
     // even though these are mocked in older Geckos (FF < 35)
-    let profilerStartTime = yield this._profiler.start(options);
+    let { startTime, position, generation, totalSize } = yield this._profiler.start(options);
     let timelineStartTime = yield this._timeline.start(options);
     let memoryStartTime = yield this._memory.start(options);
 
-    let data = { profilerStartTime, timelineStartTime, memoryStartTime };
+    let data = {
+      profilerStartTime: startTime, timelineStartTime, memoryStartTime,
+      generation, position, totalSize
+    };
 
     // Signify to the model that the recording has started,
     // populate with data and store the recording model here.
-    model.populate(data);
+    model._populate(data);
     this._recordings.push(model);
 
     this.emit("recording-started", model);
     return model;
   }),
 
   /**
    * Manually ends the recording session for the corresponding RecordingModel.
@@ -363,16 +381,19 @@ PerformanceActorsConnection.prototype = {
     let memoryEndTime = Date.now();
     let timelineEndTime = Date.now();
 
     // Only if there are no more sessions recording do we stop
     // the underlying memory and timeline actors. If we're still recording,
     // juse use Date.now() for the memory and timeline end times, as those
     // are only used in tests.
     if (!this.isRecording()) {
+      // This doesn't stop the profiler, just turns off polling for
+      // events, and also turns off events on memory/timeline actors.
+      yield this._profiler.stop();
       memoryEndTime = yield this._memory.stop(config);
       timelineEndTime = yield this._timeline.stop(config);
     }
 
     // Set the results on the RecordingModel itself.
     model._onStopRecording({
       // Data available only at the end of a recording.
       profile: profilerData.profile,
diff --git a/browser/devtools/performance/modules/graphs.js b/browser/devtools/performance/modules/graphs.js
index 5a0f24a..81720fb 100644
--- a/browser/devtools/performance/modules/graphs.js
+++ b/browser/devtools/performance/modules/graphs.js
@@ -340,17 +340,21 @@ GraphsController.prototype = {
    * Sets a mapped selection on the graph that is the main controller
    * for keeping the graphs' selections in sync.
    */
   setMappedSelection: function (selection, { mapStart, mapEnd }) {
     return this._getPrimaryLink().setMappedSelection(selection, { mapStart, mapEnd });
   },
 
   getMappedSelection: function ({ mapStart, mapEnd }) {
-    return this._getPrimaryLink().getMappedSelection({ mapStart, mapEnd });
+    if (this._getPrimaryLink()) {
+      return this._getPrimaryLink().getMappedSelection({ mapStart, mapEnd });
+    } else {
+      return null;
+    }
   },
 
   /**
    * Returns an array of graphs that have been created, not necessarily
    * enabled currently.
    */
   getWidgets: function () {
     return Object.keys(this._graphs).map(name => this._graphs[name]);
diff --git a/browser/devtools/performance/modules/recording-model.js b/browser/devtools/performance/modules/recording-model.js
index bd29ff7..1ce5d29 100644
--- a/browser/devtools/performance/modules/recording-model.js
+++ b/browser/devtools/performance/modules/recording-model.js
@@ -38,16 +38,18 @@ RecordingModel.prototype = {
   _console: false,
   _imported: false,
   _recording: false,
   _completed: false,
   _profilerStartTime: 0,
   _timelineStartTime: 0,
   _memoryStartTime: 0,
   _configuration: {},
+  _originalBufferStatus: null,
+  _bufferPercent: null,
 
   // Serializable fields, necessary and sufficient for import and export.
   _label: "",
   _duration: 0,
   _markers: null,
   _frames: null,
   _memory: null,
   _ticks: null,
@@ -85,26 +87,32 @@ RecordingModel.prototype = {
     let recordingData = this.getAllData();
     yield PerformanceIO.saveRecordingToFile(recordingData, file);
   }),
 
   /**
    * Sets up the instance with data from the SharedPerformanceConnection when
    * starting a recording. Should only be called by SharedPerformanceConnection.
    */
-  populate: function (info) {
+  _populate: function (info) {
     // Times must come from the actor in order to be self-consistent.
     // However, we also want to update the view with the elapsed time
     // even when the actor is not generating data. To do this we get
     // the local time and use it to compute a reasonable elapsed time.
     this._localStartTime = Date.now();
 
     this._profilerStartTime = info.profilerStartTime;
     this._timelineStartTime = info.timelineStartTime;
     this._memoryStartTime = info.memoryStartTime;
+    this._originalBufferStatus = {
+      position: info.position,
+      totalSize: info.totalSize,
+      generation: info.generation
+    };
+
     this._recording = true;
 
     this._markers = [];
     this._frames = [];
     this._memory = [];
     this._ticks = [];
     this._allocations = { sites: [], timestamps: [], frames: [], counts: [] };
   },
@@ -276,19 +284,45 @@ RecordingModel.prototype = {
    * A model may no longer be recording, yet still not have the profiler data. In that
    * case, use `isCompleted()`.
    */
   isRecording: function () {
     return this._recording;
   },
 
   /**
+   * Returns the percent (value between 0 and 1) of buffer used in this
+   * recording. Returns `null` for recordings that are no longer recording.
+   */
+  getBufferUsage: function () {
+    return this.isRecording() ? this._bufferPercent : null;
+  },
+
+  /**
+   * Fired whenever the PerformanceFront has new buffer data.
+   */
+  _addBufferStatusData: function (bufferStatus) {
+    // If this model isn't currently recording, or if the server does not
+    // support buffer status (or if this fires after actors are being destroyed),
+    // ignore this information.
+    if (!bufferStatus || !this.isRecording()) {
+      return;
+    }
+    let { position: currentPosition, totalSize, generation: currentGeneration } = bufferStatus;
+    let { position: origPosition, generation: origGeneration } = this._originalBufferStatus;
+
+    let normalizedCurrent = (totalSize * (currentGeneration - origGeneration)) + currentPosition;
+    let percent = (normalizedCurrent - origPosition) / totalSize;
+    this._bufferPercent = percent > 1 ? 1 : percent;
+  },
+
+  /**
    * Fired whenever the PerformanceFront emits markers, memory or ticks.
    */
-  addTimelineData: function (eventName, ...data) {
+  _addTimelineData: function (eventName, ...data) {
     // If this model isn't currently recording,
     // ignore the timeline data.
     if (!this.isRecording()) {
       return;
     }
 
     let config = this.getConfiguration();
 
@@ -338,12 +372,14 @@ RecordingModel.prototype = {
         RecordingUtils.offsetAndScaleTimestamps(timestamps, timeOffset, timeScale);
         Array.prototype.push.apply(this._allocations.sites, sites);
         Array.prototype.push.apply(this._allocations.timestamps, timestamps);
         Array.prototype.push.apply(this._allocations.frames, frames);
         Array.prototype.push.apply(this._allocations.counts, counts);
         break;
       }
     }
-  }
+  },
+
+  toString: () => "[object RecordingModel]"
 };
 
 exports.RecordingModel = RecordingModel;
diff --git a/browser/devtools/performance/test/browser.ini b/browser/devtools/performance/test/browser.ini
index c0196c7..ccf7785 100644
--- a/browser/devtools/performance/test/browser.ini
+++ b/browser/devtools/performance/test/browser.ini
@@ -14,16 +14,17 @@ support-files =
 [browser_markers-gc.js]
 [browser_markers-parse-html.js]
 [browser_perf-allocations-to-samples.js]
 [browser_perf-compatibility-01.js]
 [browser_perf-compatibility-02.js]
 [browser_perf-compatibility-03.js]
 [browser_perf-compatibility-04.js]
 [browser_perf-compatibility-05.js]
+[browser_perf-compatibility-06.js]
 [browser_perf-clear-01.js]
 [browser_perf-clear-02.js]
 [browser_perf-columns-js-calltree.js]
 [browser_perf-columns-memory-calltree.js]
 [browser_perf-console-record-01.js]
 [browser_perf-console-record-02.js]
 [browser_perf-console-record-03.js]
 [browser_perf-console-record-04.js]
@@ -85,16 +86,17 @@ support-files =
 [browser_perf-overview-selection-03.js]
 [browser_perf-overview-time-interval.js]
 [browser_perf-shared-connection-02.js]
 [browser_perf-shared-connection-03.js]
 [browser_perf-states.js]
 [browser_perf-refresh.js]
 [browser_perf-ui-recording.js]
 [browser_perf-recording-model-01.js]
+[browser_perf-recording-model-02.js]
 [browser_perf-recording-notices-01.js]
 [browser_perf-recording-notices-02.js]
 [browser_perf_recordings-io-01.js]
 [browser_perf_recordings-io-02.js]
 [browser_perf_recordings-io-03.js]
 [browser_perf_recordings-io-04.js]
 [browser_perf-range-changed-render.js]
 [browser_perf-recording-selected-01.js]
diff --git a/browser/devtools/performance/test/browser_perf-compatibility-06.js b/browser/devtools/performance/test/browser_perf-compatibility-06.js
new file mode 100644
index 0000000..6b2d894
--- /dev/null
+++ b/browser/devtools/performance/test/browser_perf-compatibility-06.js
@@ -0,0 +1,46 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+/**
+ * Tests that when using an older server (< Fx40) where the profiler actor does not
+ * have the `getBufferInfo` method that nothing breaks and RecordingModels have null
+ * `getBufferUsage()` values.
+ */
+
+function spawnTest () {
+  let { target, front } = yield initBackend(SIMPLE_URL, { TEST_MOCK_BUFFER_CHECK_TIMER: 10 });
+  let frontBufferStatusCalled = false;
+
+  // Explicitly override the profiler's `isActive` method, where
+  // all the buffer info is retrieved, and delete the buffer properties.
+  let isActive = front._connection._profiler.isActive;
+  front._connection._profiler.isActive = function () {
+    return isActive.apply(front._connection._profiler, arguments).then(res => {
+      return { isActive: res.isActive, currentTime: res.currentTime };
+    });
+  };
+
+  front.on("buffer-status", () => frontBufferStatusCalled = true);
+  let model = yield front.startRecording();
+  let [_, stats] = yield onceSpread(front._connection._profiler, "buffer-status");
+  is(stats.generation, void 0, "buffer-status has void `generation`");
+  is(stats.totalSize, void 0, "buffer-status has void `totalSize`");
+  is(stats.position, void 0, "buffer-status has void `position`");
+
+  let count = 0;
+  while (count < 5) {
+    let [_, stats] = yield onceSpread(front._connection._profiler, "buffer-status");
+    is(stats.generation, void 0, "buffer-status has void `generation`");
+    is(stats.totalSize, void 0, "buffer-status has void `totalSize`");
+    is(stats.position, void 0, "buffer-status has void `position`");
+    count++;
+  }
+
+  is(model.getBufferUsage(), null, "model should have `null` for its buffer usage");
+  yield front.stopRecording(model);
+  is(model.getBufferUsage(), null, "after recording, model should still have `null` for its buffer usage");
+  ok(!frontBufferStatusCalled, "the front should never emit a buffer-status event when not supported.");
+
+  yield removeTab(target.tab);
+  finish();
+}
diff --git a/browser/devtools/performance/test/browser_perf-recording-model-02.js b/browser/devtools/performance/test/browser_perf-recording-model-02.js
new file mode 100644
index 0000000..3bd3ea0
--- /dev/null
+++ b/browser/devtools/performance/test/browser_perf-recording-model-02.js
@@ -0,0 +1,41 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+/**
+ * Test that buffer status is correctly updated in recording models.
+ */
+
+let BUFFER_SIZE = 20000;
+
+function spawnTest () {
+  let { target, front } = yield initBackend(SIMPLE_URL, { TEST_MOCK_BUFFER_CHECK_TIMER: 10 });
+  let config = { bufferSize: BUFFER_SIZE };
+
+  let model = yield front.startRecording(config);
+  let [_, stats] = yield onceSpread(front, "buffer-status");
+  is(stats.totalSize, BUFFER_SIZE, `buffer-status event has correct totalSize: ${stats.totalSize}`);
+  ok(stats.position < BUFFER_SIZE, `buffer-status event has correct position: ${stats.position}`);
+  is(stats.generation, 0, `buffer-status event has correct generation: ${stats.generation}`);
+
+  // Halt once more for a buffer status to ensure we're beyond 0
+  yield once(front, "buffer-status");
+
+  let lastBufferStatus = 0;
+  let checkCount = 0;
+  while (lastBufferStatus < 1) {
+    let currentBufferStatus = model.getBufferUsage();
+    ok(currentBufferStatus > lastBufferStatus, `buffer is more filled than before: ${currentBufferStatus}`);
+    lastBufferStatus = currentBufferStatus;
+    checkCount++;
+    yield once(front, "buffer-status");
+  }
+
+  ok(checkCount >= 1, "atleast 1 event were fired until the buffer was filled");
+  is(lastBufferStatus, 1, "buffer usage cannot surpass 100%");
+  yield front.stopRecording(model);
+
+  is(model.getBufferUsage(), null, "getBufferUsage() should be null when no longer recording.");
+
+  yield removeTab(target.tab);
+  finish();
+}
diff --git a/browser/devtools/performance/test/head.js b/browser/devtools/performance/test/head.js
index 900308e..6f473c7 100644
--- a/browser/devtools/performance/test/head.js
+++ b/browser/devtools/performance/test/head.js
@@ -190,16 +190,17 @@ function initBackend(aUrl, targetOps={}) {
 
     yield target.makeRemote();
 
     // Attach addition options to `target`. This is used to force mock fronts
     // to smokescreen test different servers where memory or timeline actors
     // may not exist. Possible options that will actually work:
     // TEST_MOCK_MEMORY_ACTOR = true
     // TEST_MOCK_TIMELINE_ACTOR = true
+    // TEST_MOCK_BUFFER_CHECK_TIMER = number
     merge(target, targetOps);
 
     let connection = getPerformanceActorsConnection(target);
     yield connection.open();
 
     let front = new PerformanceFront(connection);
     return { target, front };
   });
diff --git a/browser/devtools/performance/views/overview.js b/browser/devtools/performance/views/overview.js
index 7760c7c..8721495 100644
--- a/browser/devtools/performance/views/overview.js
+++ b/browser/devtools/performance/views/overview.js
@@ -150,16 +150,21 @@ let OverviewView = {
       throw new Error("A recording should be available in order to get the selection.");
     }
     if (this.isDisabled()) {
       return { startTime: 0, endTime: recording.getDuration() };
     }
     let mapStart = () => 0;
     let mapEnd = () => recording.getDuration();
     let selection = this.graphs.getMappedSelection({ mapStart, mapEnd });
+    // If no selection returned, this means the overview graphs have not been rendered
+    // yet, so act as if we have no selection (the full recording).
+    if (!selection) {
+      return { startTime: 0, endTime: recording.getDuration() };
+    }
     return { startTime: selection.min, endTime: selection.max };
   },
 
   /**
    * Method for handling all the set up for rendering the overview graphs.
    *
    * @param number resolution
    *        The fps graph resolution. @see Graphs.jsm
diff --git a/toolkit/devtools/server/actors/profiler.js b/toolkit/devtools/server/actors/profiler.js
index 380741e..f693cea 100644
--- a/toolkit/devtools/server/actors/profiler.js
+++ b/toolkit/devtools/server/actors/profiler.js
@@ -54,17 +54,22 @@ ProfilerActor.prototype = {
    * Returns an array of feature strings, describing the profiler features
    * that are available on this platform. Can be called while the profiler
    * is stopped.
    */
   onGetFeatures: function() {
     return { features: nsIProfilerModule.GetFeatures([]) };
   },
 
-  onGetBufferInfo: function(request) {
+  /**
+   * Returns an object with the values of the current status of the
+   * circular buffer in the profiler, returning `position`, `totalSize`,
+   * and the current `generation` of the buffer.
+   */
+  onGetBufferInfo: function() {
     let position = {}, totalSize = {}, generation = {};
     nsIProfilerModule.GetBufferInfo(position, totalSize, generation);
     return {
       position: position.value,
       totalSize: totalSize.value,
       generation: generation.value
     }
   },
@@ -97,18 +102,19 @@ ProfilerActor.prototype = {
     nsIProfilerModule.StartProfiler(
       options.entries,
       options.interval,
       options.features,
       options.features.length,
       options.threadFilters,
       options.threadFilters.length
     );
+    let { position, totalSize, generation } = this.onGetBufferInfo();
 
-    return { started: true };
+    return { started: true, position, totalSize, generation };
   },
 
   /**
    * Stops the nsIProfiler module, if no other client is using it.
    */
   onStopProfiler: function() {
     // Actually stop the profiler only if the last client has stopped profiling.
     // Since this is a root actor, and the profiler module interacts with the
@@ -122,17 +128,18 @@ ProfilerActor.prototype = {
 
   /**
    * Verifies whether or not the nsIProfiler module has started.
    * If already active, the current time is also returned.
    */
   onIsActive: function() {
     let isActive = nsIProfilerModule.IsActive();
     let elapsedTime = isActive ? nsIProfilerModule.getElapsedTime() : undefined;
-    return { isActive: isActive, currentTime: elapsedTime };
+    let { position, totalSize, generation } = this.onGetBufferInfo();
+    return { isActive: isActive, currentTime: elapsedTime, position, totalSize, generation };
   },
 
   /**
    * Returns a stringified JSON object that describes the shared libraries
    * which are currently loaded into our process. Can be called while the
    * profiler is stopped.
    */
   onGetSharedLibraryInformation: function() {
diff --git a/toolkit/devtools/server/actors/root.js b/toolkit/devtools/server/actors/root.js
index 7a146bc..98f1669 100644
--- a/toolkit/devtools/server/actors/root.js
+++ b/toolkit/devtools/server/actors/root.js
@@ -166,20 +166,17 @@ RootActor.prototype = {
     // if allocChromeProcess is defined, but not true, it means that root actor
     // no longer expose tab actors, but also that getProcess forbids
     // exposing actors for security reasons
     get allowChromeProcess() {
       return DebuggerServer.allowChromeProcess;
     },
     // Whether or not `getProfile()` supports specifying a `startTime`
     // and `endTime` to filter out samples. Fx40+
-    profilerDataFilterable: true,
-    // Whether or not the profiler has a `getBufferInfo` method
-    // necessary as the profiler does not use the ActorFront class.
-    profilerBufferStatus: true,
+    profilerDataFilterable: true
   },
 
   /**
    * Return a 'hello' packet as specified by the Remote Debugging Protocol.
    */
   sayHello: function() {
     return {
       from: this.actorID,
diff --git a/toolkit/devtools/server/tests/unit/test_profiler_activation-01.js b/toolkit/devtools/server/tests/unit/test_profiler_activation-01.js
index 0ad40e8..30519c3 100644
--- a/toolkit/devtools/server/tests/unit/test_profiler_activation-01.js
+++ b/toolkit/devtools/server/tests/unit/test_profiler_activation-01.js
@@ -4,16 +4,17 @@
 "use strict";
 
 /**
  * Tests whether the profiler module and actor have the correct state on
  * initialization, activation, and when a clients' connection closes.
  */
 
 const Profiler = Cc["@mozilla.org/tools/profiler;1"].getService(Ci.nsIProfiler);
+const MAX_PROFILER_ENTRIES = 10000000;
 
 function run_test()
 {
   // Ensure the profiler is not running when the test starts (it could
   // happen if the MOZ_PROFILER_STARTUP environment variable is set).
   Profiler.StopProfiler();
 
   get_chrome_actors((client1, form1) => {
@@ -30,27 +31,40 @@ function run_test()
 }
 
 function test_activate(client1, actor1, client2, actor2, callback) {
   // Profiler should be inactive at this point.
   client1.request({ to: actor1, type: "isActive" }, response => {
     do_check_false(Profiler.IsActive());
     do_check_false(response.isActive);
     do_check_eq(response.currentTime, undefined);
+    do_check_true(typeof response.position === "number");
+    do_check_true(typeof response.totalSize === "number");
+    do_check_true(typeof response.generation === "number");
 
     // Start the profiler on the first connection....
-    client1.request({ to: actor1, type: "startProfiler" }, response => {
+    client1.request({ to: actor1, type: "startProfiler", entries: MAX_PROFILER_ENTRIES }, response => {
       do_check_true(Profiler.IsActive());
       do_check_true(response.started);
+      do_check_true(typeof response.position === "number");
+      do_check_true(typeof response.totalSize === "number");
+      do_check_true(typeof response.generation === "number");
+      do_check_true(response.position >= 0 && response.position < response.totalSize);
+      do_check_true(response.totalSize === MAX_PROFILER_ENTRIES);
 
       // On the next connection just make sure the actor has been instantiated.
       client2.request({ to: actor2, type: "isActive" }, response => {
         do_check_true(Profiler.IsActive());
         do_check_true(response.isActive);
         do_check_true(response.currentTime > 0);
+        do_check_true(typeof response.position === "number");
+        do_check_true(typeof response.totalSize === "number");
+        do_check_true(typeof response.generation === "number");
+        do_check_true(response.position >= 0 && response.position < response.totalSize);
+        do_check_true(response.totalSize === MAX_PROFILER_ENTRIES);
 
         let origConnectionClosed = DebuggerServer._connectionClosed;
 
         DebuggerServer._connectionClosed = function(conn) {
           origConnectionClosed.call(this, conn);
 
           // The first client is the only actor that started the profiler,
           // however the second client can request the accumulated profile data
diff --git a/toolkit/devtools/server/tests/unit/test_profiler_bufferstatus.js b/toolkit/devtools/server/tests/unit/test_profiler_bufferstatus.js
new file mode 100644
index 0000000..979f84c
--- /dev/null
+++ b/toolkit/devtools/server/tests/unit/test_profiler_bufferstatus.js
@@ -0,0 +1,127 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+/**
+ * Tests if the profiler actor returns its buffer status via getBufferInfo.
+ */
+
+const Profiler = Cc["@mozilla.org/tools/profiler;1"].getService(Ci.nsIProfiler);
+const INITIAL_WAIT_TIME = 100; // ms
+const MAX_WAIT_TIME = 20000; // ms
+const MAX_PROFILER_ENTRIES = 10000000;
+
+function run_test()
+{
+  // Ensure the profiler is not running when the test starts (it could
+  // happen if the MOZ_PROFILER_STARTUP environment variable is set).
+  Profiler.StopProfiler();
+
+  get_chrome_actors((client, form) => {
+    let actor = form.profilerActor;
+    check_empty_buffer(client, actor, () => {
+      activate_profiler(client, actor, startTime => {
+        wait_for_samples(client, actor, () => {
+          check_buffer(client, actor, () => {
+            deactivate_profiler(client, actor, () => {
+              client.close(do_test_finished);
+            });
+          });
+        });
+      });
+    });
+  })
+
+  do_test_pending();
+}
+
+function check_buffer(client, actor, callback)
+{
+  client.request({ to: actor, type: "isActive" }, response => {
+    do_check_true(typeof response.position === "number");
+    do_check_true(typeof response.totalSize === "number");
+    do_check_true(typeof response.generation === "number");
+    do_check_true(response.position > 0 && response.position < response.totalSize);
+    do_check_true(response.totalSize === MAX_PROFILER_ENTRIES);
+    // There's no way we'll fill the buffer in this test.
+    do_check_true(response.generation === 0);
+
+    callback();
+  });
+}
+
+function check_empty_buffer(client, actor, callback)
+{
+  client.request({ to: actor, type: "isActive" }, response => {
+    do_check_false(Profiler.IsActive());
+    do_check_false(response.isActive);
+    do_check_true(response.position === void 0);
+    do_check_true(response.totalSize === void 0);
+    do_check_true(response.generation === void 0);
+    do_check_false(response.isActive);
+    do_check_eq(response.currentTime, undefined);
+    calback();
+  });
+}
+
+function activate_profiler(client, actor, callback)
+{
+  client.request({ to: actor, type: "startProfiler", entries: MAX_PROFILER_ENTRIES }, response => {
+    do_check_true(response.started);
+    client.request({ to: actor, type: "isActive" }, response => {
+      do_check_true(response.isActive);
+      callback(response.currentTime);
+    });
+  });
+}
+
+function deactivate_profiler(client, actor, callback)
+{
+  client.request({ to: actor, type: "stopProfiler" }, response => {
+    do_check_false(response.started);
+    client.request({ to: actor, type: "isActive" }, response => {
+      do_check_false(response.isActive);
+      callback();
+    });
+  });
+}
+
+function wait_for_samples(client, actor, callback)
+{
+  function attempt(delay)
+  {
+    // No idea why, but Components.stack.sourceLine returns null.
+    let funcLine = Components.stack.lineNumber - 3;
+
+    // Spin for the requested time, then take a sample.
+    let start = Date.now();
+    let stack;
+    do_print("Attempt: delay = " + delay);
+    while (Date.now() - start < delay) { stack = Components.stack; }
+    do_print("Attempt: finished waiting.");
+
+    client.request({ to: actor, type: "getProfile" }, response => {
+      // At this point, we may or may not have samples, depending on
+      // whether the spin loop above has given the profiler enough time
+      // to get started.
+      if (response.profile.threads[0].samples.length == 0) {
+        if (delay < MAX_WAIT_TIME) {
+          // Double the spin-wait time and try again.
+          do_print("Attempt: no samples, going around again.");
+          return attempt(delay * 2);
+        } else {
+          // We've waited long enough, so just fail.
+          do_print("Attempt: waited a long time, but no samples were collected.");
+          do_print("Giving up.");
+          do_check_true(false);
+          return;
+        }
+      }
+      callback();
+    });
+  }
+
+  // Start off with a 100 millisecond delay.
+  attempt(INITIAL_WAIT_TIME);
+}
diff --git a/toolkit/devtools/server/tests/unit/test_profiler_getbufferinfo.js b/toolkit/devtools/server/tests/unit/test_profiler_getbufferinfo.js
index 26d9e71..7aa078b 100644
--- a/toolkit/devtools/server/tests/unit/test_profiler_getbufferinfo.js
+++ b/toolkit/devtools/server/tests/unit/test_profiler_getbufferinfo.js
@@ -9,32 +9,48 @@
 
 const Profiler = Cc["@mozilla.org/tools/profiler;1"].getService(Ci.nsIProfiler);
 const INITIAL_WAIT_TIME = 100; // ms
 const MAX_WAIT_TIME = 20000; // ms
 const MAX_PROFILER_ENTRIES = 10000000;
 
 function run_test()
 {
+  // Ensure the profiler is not running when the test starts (it could
+  // happen if the MOZ_PROFILER_STARTUP environment variable is set).
+  Profiler.StopProfiler();
+
   get_chrome_actors((client, form) => {
     let actor = form.profilerActor;
-    activate_profiler(client, actor, startTime => {
-      wait_for_samples(client, actor, () => {
-        check_buffer(client, actor, () => {
-          deactivate_profiler(client, actor, () => {
-            client.close(do_test_finished);
+    check_empty_buffer(client, actor, () => {
+      activate_profiler(client, actor, startTime => {
+        wait_for_samples(client, actor, () => {
+          check_buffer(client, actor, () => {
+            deactivate_profiler(client, actor, () => {
+              client.close(do_test_finished);
+            });
           });
         });
       });
     });
   })
 
   do_test_pending();
 }
 
+function check_empty_buffer(client, actor, callback)
+{
+  client.request({ to: actor, type: "getBufferInfo" }, response => {
+    do_check_true(response.position === 0);
+    do_check_true(response.totalSize === 0);
+    do_check_true(response.generation === 0);
+    callback();
+  });
+}
+
 function check_buffer(client, actor, callback)
 {
   client.request({ to: actor, type: "getBufferInfo" }, response => {
     do_check_true(typeof response.position === "number");
     do_check_true(typeof response.totalSize === "number");
     do_check_true(typeof response.generation === "number");
     do_check_true(response.position > 0 && response.position < response.totalSize);
     do_check_true(response.totalSize === MAX_PROFILER_ENTRIES);
-- 
2.2.1

