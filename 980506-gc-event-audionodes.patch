From 93c44b2f3c7265fc1d581220261d7d70d7270b7b Mon Sep 17 00:00:00 2001
From: Jordan Santell <jsantell@gmail.com>
Date: Mon, 9 Jun 2014 12:32:03 -0700
Subject: [PATCH] Bug 980506 - Implement WebAudioActor destruction events on
 the devtools server.

---
 browser/devtools/webaudioeditor/test/browser.ini   |   3 +
 .../test/browser_webaudio-actor-destroy-node.js    |  41 ++++++
 .../webaudioeditor/test/doc_destroy-nodes.html     |  32 +++++
 browser/devtools/webaudioeditor/test/head.js       |  14 ++
 toolkit/devtools/server/actors/call-watcher.js     |  10 +-
 toolkit/devtools/server/actors/webaudio.js         | 159 +++++++++++++++------
 6 files changed, 215 insertions(+), 44 deletions(-)
 create mode 100644 browser/devtools/webaudioeditor/test/browser_webaudio-actor-destroy-node.js
 create mode 100644 browser/devtools/webaudioeditor/test/doc_destroy-nodes.html

diff --git a/browser/devtools/webaudioeditor/test/browser.ini b/browser/devtools/webaudioeditor/test/browser.ini
index 3616124..4858434 100644
--- a/browser/devtools/webaudioeditor/test/browser.ini
+++ b/browser/devtools/webaudioeditor/test/browser.ini
@@ -2,25 +2,28 @@
 skip-if = e10s # Bug ?????? - devtools tests disabled with e10s
 subsuite = devtools
 support-files =
   doc_simple-context.html
   doc_complex-context.html
   doc_simple-node-creation.html
   doc_buffer-and-array.html
   440hz_sine.ogg
+  doc_destroy-nodes.html
   head.js
 
 [browser_audionode-actor-get-set-param.js]
 [browser_audionode-actor-get-type.js]
 [browser_audionode-actor-get-params-01.js]
 [browser_audionode-actor-get-params-02.js]
 [browser_audionode-actor-get-param-flags.js]
 [browser_audionode-actor-is-source.js]
+
 [browser_webaudio-actor-simple.js]
+[browser_webaudio-actor-destroy-node.js]
 
 [browser_wa_first-run.js]
 [browser_wa_reset-01.js]
 [browser_wa_reset-02.js]
 [browser_wa_reset-03.js]
 
 [browser_wa_graph-click.js]
 [browser_wa_graph-render-01.js]
diff --git a/browser/devtools/webaudioeditor/test/browser_webaudio-actor-destroy-node.js b/browser/devtools/webaudioeditor/test/browser_webaudio-actor-destroy-node.js
new file mode 100644
index 0000000..88dc96b
--- /dev/null
+++ b/browser/devtools/webaudioeditor/test/browser_webaudio-actor-destroy-node.js
@@ -0,0 +1,41 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+/**
+ * Test `destroy-node` event on WebAudioActor.
+ */
+
+function spawnTest () {
+  let [target, debuggee, front] = yield initBackend(DESTROY_NODES_URL);
+
+  let waitUntilDestroyed = getN(front, "destroy-node", 10);
+  let [_, _, created] = yield Promise.all([
+    front.setup({ reload: true }),
+    once(front, "start-context"),
+    // Should create 1 destination node and 10 disposable buffer nodes
+    getN(front, "create-node", 13)
+  ]);
+
+  // Force CC so we can ensure it's run to clear out dead AudioNodes
+  forceCC();
+
+  let destroyed = yield waitUntilDestroyed;
+
+  let destroyedTypes = yield Promise.all(destroyed.map(actor => actor.getType()));
+  destroyedTypes.forEach((type, i) => {
+    ok(type, "AudioBufferSourceNode", "Only buffer nodes are destroyed");
+    ok(actorIsInList(created, destroyed[i]),
+      "`destroy-node` called only on AudioNodes in current document.");
+  });
+
+  yield removeTab(target.tab);
+  finish();
+}
+
+function actorIsInList (list, actor) {
+  for (let i = 0; i < list.length; i++) {
+    if (list[i].actorID === actor.actorID)
+      return list[i];
+  }
+  return null;
+}
diff --git a/browser/devtools/webaudioeditor/test/doc_destroy-nodes.html b/browser/devtools/webaudioeditor/test/doc_destroy-nodes.html
new file mode 100644
index 0000000..d1577096
--- /dev/null
+++ b/browser/devtools/webaudioeditor/test/doc_destroy-nodes.html
@@ -0,0 +1,32 @@
+<!-- Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/publicdomain/zero/1.0/ -->
+<!doctype html>
+
+<html>
+  <head>
+    <meta charset="utf-8"/>
+	<title>Web Audio Editor test page</title>
+  </head>
+
+  <body>
+
+    <script type="text/javascript;version=1.8">
+      "use strict";
+	  (function () {
+      let ctx = new AudioContext();
+      let osc = ctx.createOscillator();
+      let gain = ctx.createGain();
+
+      for (let i = 0; i < 10; i++) {
+        ctx.createBufferSource();
+      }
+
+      osc.connect(gain);
+      gain.connect(ctx.destination);
+      gain.gain.value = 0;
+	  osc.start();
+	  })();
+    </script>
+  </body>
+
+</html>
diff --git a/browser/devtools/webaudioeditor/test/head.js b/browser/devtools/webaudioeditor/test/head.js
index 386ab2b..0bd5ad7 100644
--- a/browser/devtools/webaudioeditor/test/head.js
+++ b/browser/devtools/webaudioeditor/test/head.js
@@ -20,26 +20,31 @@ let { DebuggerServer } = Cu.import("resource://gre/modules/devtools/dbg-server.j
 let { WebAudioFront } = devtools.require("devtools/server/actors/webaudio");
 let TargetFactory = devtools.TargetFactory;
 
 const EXAMPLE_URL = "http://example.com/browser/browser/devtools/webaudioeditor/test/";
 const SIMPLE_CONTEXT_URL = EXAMPLE_URL + "doc_simple-context.html";
 const COMPLEX_CONTEXT_URL = EXAMPLE_URL + "doc_complex-context.html";
 const SIMPLE_NODES_URL = EXAMPLE_URL + "doc_simple-node-creation.html";
 const BUFFER_AND_ARRAY_URL = EXAMPLE_URL + "doc_buffer-and-array.html";
+const DESTROY_NODES_URL = EXAMPLE_URL + "doc_destroy-nodes.html";
 
 // All tests are asynchronous.
 waitForExplicitFinish();
 
 let gToolEnabled = Services.prefs.getBoolPref("devtools.webaudioeditor.enabled");
 
 registerCleanupFunction(() => {
   info("finish() was called, cleaning up...");
   Services.prefs.setBoolPref("devtools.debugger.log", gEnableLogging);
   Services.prefs.setBoolPref("devtools.webaudioeditor.enabled", gToolEnabled);
+
+  // Properly shut down DebuggerServer to avoid memory leaks.
+  DebuggerServer.destroy();
+
   Cu.forceGC();
 });
 
 function addTab(aUrl, aWindow) {
   info("Adding tab: " + aUrl);
 
   let deferred = Promise.defer();
   let targetWindow = aWindow || window;
@@ -357,16 +362,25 @@ function getGripValue (value) {
 function countGraphObjects (win) {
   return {
     nodes: win.document.querySelectorAll(".nodes > .audionode").length,
     edges: win.document.querySelectorAll(".edgePaths > .edgePath").length
   }
 }
 
 /**
+ * Forces cycle collection and GC, used in AudioNode destruction tests.
+ */
+function forceCC () {
+  SpecialPowers.DOMWindowUtils.cycleCollect();
+  SpecialPowers.DOMWindowUtils.garbageCollect();
+  SpecialPowers.DOMWindowUtils.garbageCollect();
+}
+
+/**
  * List of audio node properties to test against expectations of the AudioNode actor
  */
 
 const NODE_DEFAULT_VALUES = {
   "AudioDestinationNode": {},
   "AudioBufferSourceNode": {
     "playbackRate": 1,
     "loop": false,
diff --git a/toolkit/devtools/server/actors/call-watcher.js b/toolkit/devtools/server/actors/call-watcher.js
index 3c986d9..c77c92c 100644
--- a/toolkit/devtools/server/actors/call-watcher.js
+++ b/toolkit/devtools/server/actors/call-watcher.js
@@ -67,25 +67,31 @@ let FunctionCallActor = protocol.ActorClass({
    * @param array args
    *        The called function's arguments.
    * @param any result
    *        The value returned by the function call.
    */
   initialize: function(conn, [window, global, caller, type, name, stack, args, result]) {
     protocol.Actor.prototype.initialize.call(this, conn);
 
-    this.details = {
+    // Store a weak reference to all objects so we don't
+    // prevent natural GC.
+    let weakDetails = Cu.getWeakReference({
       window: window,
       caller: caller,
       type: type,
       name: name,
       stack: stack,
       args: args,
       result: result
-    };
+    });
+
+    Object.defineProperty(this, "details", {
+      get: () => weakDetails.get() || {}
+    });
 
     this.meta = {
       global: -1,
       previews: { caller: "", args: "" }
     };
 
     if (global == "WebGLRenderingContext") {
       this.meta.global = CallWatcherFront.CANVAS_WEBGL_CONTEXT;
diff --git a/toolkit/devtools/server/actors/webaudio.js b/toolkit/devtools/server/actors/webaudio.js
index c0ab879..bcceb29 100644
--- a/toolkit/devtools/server/actors/webaudio.js
+++ b/toolkit/devtools/server/actors/webaudio.js
@@ -3,22 +3,21 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 const {Cc, Ci, Cu, Cr} = require("chrome");
 
 const Services = require("Services");
 
 const { Promise: promise } = Cu.import("resource://gre/modules/Promise.jsm", {});
-const events = require("sdk/event/core");
+const { on, off, emit } = require("sdk/event/core");
+const { on: systemOn, off: systemOff } = require("sdk/system/events");
 const protocol = require("devtools/server/protocol");
-const { CallWatcherActor, CallWatcherFront } = require("devtools/server/actors/call-watcher");
+const { CallWatcherActor } = require("devtools/server/actors/call-watcher");
 const { ThreadActor } = require("devtools/server/actors/script");
-
-const { on, once, off, emit } = events;
 const { method, Arg, Option, RetVal } = protocol;
 
 exports.register = function(handle) {
   handle.addTabActor(WebAudioActor, "webaudioActor");
 };
 
 exports.unregister = function(handle) {
   handle.removeTabActor(WebAudioActor);
@@ -103,38 +102,40 @@ const NODE_PROPERTIES = {
     "frequencyBinCount": { "readonly": true },
   },
   "AudioDestinationNode": {},
   "ChannelSplitterNode": {},
   "ChannelMergerNode": {}
 };
 
 /**
- * Track an array of audio nodes
-
-/**
  * An Audio Node actor allowing communication to a specific audio node in the
  * Audio Context graph.
  */
 let AudioNodeActor = exports.AudioNodeActor = protocol.ActorClass({
   typeName: "audionode",
 
   /**
    * Create the Audio Node actor.
    *
    * @param DebuggerServerConnection conn
    *        The server connection.
    * @param AudioNode node
    *        The AudioNode that was created.
    */
   initialize: function (conn, node) {
     protocol.Actor.prototype.initialize.call(this, conn);
-    this.node = unwrap(node);
+
+    // Store ChromeOnly property `id` to identify AudioNode
+    // on `webaudio-node-demise` event.
+    this.nativeID = node.id;
+
+    this.node = Cu.getWeakReference(node);
     try {
-      this.type = getConstructorName(this.node);
+      this.type = getConstructorName(node);
     } catch (e) {
       this.type = "";
     }
   },
 
   /**
    * Returns the name of the audio type.
    * Examples: "OscillatorNode", "MediaElementAudioSourceNode"
@@ -160,21 +161,22 @@ let AudioNodeActor = exports.AudioNodeActor = protocol.ActorClass({
    * on success, or a description of the error upon param set failure.
    *
    * @param String param
    *        Name of the AudioParam to change.
    * @param String value
    *        Value to change AudioParam to.
    */
   setParam: method(function (param, value) {
+    let node = this.node.get();
     try {
-      if (isAudioParam(this.node, param))
-        this.node[param].value = value;
+      if (isAudioParam(node, param))
+        node[param].value = value;
       else
-        this.node[param] = value;
+        node[param] = value;
       return undefined;
     } catch (e) {
       return constructError(e);
     }
   }, {
     request: {
       param: Arg(0, "string"),
       value: Arg(1, "nullable:primitive")
@@ -184,19 +186,20 @@ let AudioNodeActor = exports.AudioNodeActor = protocol.ActorClass({
 
   /**
    * Gets a param on the audio node.
    *
    * @param String param
    *        Name of the AudioParam to fetch.
    */
   getParam: method(function (param) {
+    let node = this.node.get();
     // Check to see if it's an AudioParam -- if so,
     // return the `value` property of the parameter.
-    let value = isAudioParam(this.node, param) ? this.node[param].value : this.node[param];
+    let value = isAudioParam(node, param) ? node[param].value : node[param];
 
     // Return the grip form of the value; at this time,
     // there shouldn't be any non-primitives at the moment, other than
     // AudioBuffer or Float32Array references and the like,
     // so this just formats the value to be displayed in the VariablesView,
     // without using real grips and managing via actor pools.
     let grip;
     try {
@@ -256,18 +259,21 @@ let AudioNodeFront = protocol.FrontClass(AudioNodeActor, {
  * The Web Audio Actor handles simple interaction with an AudioContext
  * high-level methods. After instantiating this actor, you'll need to set it
  * up by calling setup().
  */
 let WebAudioActor = exports.WebAudioActor = protocol.ActorClass({
   typeName: "webaudio",
   initialize: function(conn, tabActor) {
     protocol.Actor.prototype.initialize.call(this, conn);
+    this.conn = conn;
     this.tabActor = tabActor;
     this._onContentFunctionCall = this._onContentFunctionCall.bind(this);
+    this._onDestroyNode = this._onDestroyNode.bind(this);
+    this._onGlobalDestroyed = this._onGlobalDestroyed.bind(this);
   },
 
   destroy: function(conn) {
     protocol.Actor.prototype.destroy.call(this, conn);
     this.finalize();
   },
 
   /**
@@ -277,31 +283,45 @@ let WebAudioActor = exports.WebAudioActor = protocol.ActorClass({
    *
    * See ContentObserver and WebAudioInstrumenter for more details.
    */
   setup: method(function({ reload }) {
     // Used to track when something is happening with the web audio API
     // the first time, to ultimately fire `start-context` event
     this._firstNodeCreated = false;
 
+    // Clear out stored nativeIDs on reload as we do not want to track
+    // AudioNodes that are no longer on this document.
+    if (this._nativeToActorID) {
+      this._nativeToActorID.clear();
+    }
+
     if (this._initialized) {
       return;
     }
+
     this._initialized = true;
 
-    // Weak map mapping audio nodes to their corresponding actors
-    this._nodeActors = new Map();
+    // Store ChromeOnly ID (`nativeID` property on AudioNodeActor) mapped
+    // to the associated actorID, so we don't have to expose `nativeID`
+    // to the client.
+    this._nativeToActorID = new Map();
 
     this._callWatcher = new CallWatcherActor(this.conn, this.tabActor);
     this._callWatcher.onCall = this._onContentFunctionCall;
     this._callWatcher.setup({
       tracedGlobals: AUDIO_GLOBALS,
       startRecording: true,
       performReload: reload
     });
+    // Bind to the `global-destroyed` event on the content observer so we can
+    // unbind events between the global destruction and the `finalize` cleanup
+    // method on the actor.
+    // TODO expose these events on CallWatcherActor itself, bug 1021321
+    on(this._callWatcher._contentObserver, "global-destroyed", this._onGlobalDestroyed);
   }, {
     request: { reload: Option(0, "boolean") },
     oneway: true
   }),
 
   /**
    * Invoked whenever an instrumented function is called, like an AudioContext
    * method or an AudioNode method.
@@ -316,19 +336,19 @@ let WebAudioActor = exports.WebAudioActor = protocol.ActorClass({
     }
     else if (WebAudioFront.NODE_CREATION_METHODS.has(name)) {
       this._handleCreationCall(functionCall);
     }
   },
 
   _handleRoutingCall: function(functionCall) {
     let { caller, args, window, name } = functionCall.details;
-    let source = unwrap(caller);
-    let dest = unwrap(args[0]);
-    let isAudioParam = dest instanceof unwrap(window.AudioParam);
+    let source = wrap(caller);
+    let dest = wrap(args[0]);
+    let isAudioParam = dest instanceof wrap(window.AudioParam);
 
     // audionode.connect(param)
     if (name === "connect" && isAudioParam) {
       this._onConnectParam(source, dest);
     }
     // audionode.connect(node)
     else if (name === "connect") {
       this._onConnectNode(source, dest);
@@ -344,34 +364,37 @@ let WebAudioActor = exports.WebAudioActor = protocol.ActorClass({
     // Keep track of the first node created, so we can alert
     // the front end that an audio context is being used since
     // we're not hooking into the constructor itself, just its
     // instance's methods.
     if (!this._firstNodeCreated) {
       // Fire the start-up event if this is the first node created
       // and trigger a `create-node` event for the context destination
       this._onStartContext();
-      this._onCreateNode(unwrap(caller.destination));
+      this._onCreateNode(wrap(caller.destination));
       this._firstNodeCreated = true;
     }
-    this._onCreateNode(result);
+    this._onCreateNode(wrap(result));
   },
 
   /**
    * Stops listening for document global changes and puts this actor
    * to hibernation. This method is called automatically just before the
    * actor is destroyed.
    */
   finalize: method(function() {
     if (!this._initialized) {
       return;
     }
+    this._nativeToActorID = null;
+    this.conn = null;
+    this.tabActor = null;
     this._initialized = false;
+    off(this._callWatcher._contentObserver, "global-destroyed", this._onGlobalDestroyed);
     this._callWatcher.eraseRecording();
-
     this._callWatcher.finalize();
     this._callWatcher = null;
   }, {
    oneway: true
   }),
 
   /**
    * Events emitted by this actor.
@@ -398,59 +421,70 @@ let WebAudioActor = exports.WebAudioActor = protocol.ActorClass({
       type: "changeParam",
       source: Option(0, "audionode"),
       param: Option(0, "string"),
       value: Option(0, "string")
     },
     "create-node": {
       type: "createNode",
       source: Arg(0, "audionode")
+    },
+    "destroy-node": {
+      type: "destroyNode",
+      source: Arg(0, "audionode")
     }
   },
 
   /**
    * Helper for constructing an AudioNodeActor, assigning to
    * internal weak map, and tracking via `manage` so it is assigned
    * an `actorID`.
    */
   _constructAudioNode: function (node) {
     let actor = new AudioNodeActor(this.conn, node);
     this.manage(actor);
-    this._nodeActors.set(node, actor);
+    this._nativeToActorID.set(node.id, actor.actorID);
     return actor;
   },
 
   /**
-   * Takes an AudioNode and returns the stored actor for it.
-   * In some cases, we won't have an actor stored (for example,
-   * connecting to an AudioDestinationNode, since it's implicitly
-   * created), so make a new actor and store that.
+   *
    */
-  _actorFor: function (node) {
-    let actor = this._nodeActors.get(node);
-    if (!actor) {
-      actor = this._constructAudioNode(node);
+  _getActorByNativeID: function (nativeID) {
+    // Ensure we have a Number, rather than a string
+    // returned via notification
+    nativeID = ~~nativeID;
+
+    // Ensure that this doesn't attempt to fetch actors after
+    // clean up.
+    if (!this._nativeToActorID) {
+      return null;
     }
+
+    let actorID = this._nativeToActorID.get(nativeID);
+    let actor = actorID != null ? this.conn.getActor(actorID) : null;
     return actor;
   },
 
   /**
    * Called on first audio node creation, signifying audio context usage
    */
   _onStartContext: function () {
-    events.emit(this, "start-context");
+    systemOn("webaudio-node-demise", this._onDestroyNode);
+
+    emit(this, "start-context");
   },
 
   /**
    * Called when one audio node is connected to another.
    */
   _onConnectNode: function (source, dest) {
-    let sourceActor = this._actorFor(source);
-    let destActor = this._actorFor(dest);
-    events.emit(this, "connect-node", {
+    let sourceActor = this._getActorByNativeID(source.id);
+    let destActor = this._getActorByNativeID(dest.id);
+    emit(this, "connect-node", {
       source: sourceActor,
       dest: destActor
     });
   },
 
   /**
    * Called when an audio node is connected to an audio param.
    * Implement in bug 986705
@@ -458,39 +492,75 @@ let WebAudioActor = exports.WebAudioActor = protocol.ActorClass({
   _onConnectParam: function (source, dest) {
     // TODO bug 986705
   },
 
   /**
    * Called when an audio node is disconnected.
    */
   _onDisconnectNode: function (node) {
-    let actor = this._actorFor(node);
-    events.emit(this, "disconnect-node", actor);
+    let actor = this._getActorByNativeID(node.id);
+    emit(this, "disconnect-node", actor);
   },
 
   /**
    * Called when a parameter changes on an audio node
    */
   _onParamChange: function (node, param, value) {
-    let actor = this._actorFor(node);
-    events.emit(this, "param-change", {
+    let actor = this._getActorByNativeID(node.id);
+    emit(this, "param-change", {
       source: actor,
       param: param,
       value: value
     });
   },
 
   /**
    * Called on node creation.
    */
   _onCreateNode: function (node) {
     let actor = this._constructAudioNode(node);
-    events.emit(this, "create-node", actor);
-  }
+    emit(this, "create-node", actor);
+  },
+
+  /**
+   * Called when `webaudio-node-demise` is triggered,
+   * and emits the associated actor to the front if found.
+   */
+  _onDestroyNode: function ({data}) {
+    // Cast to integer
+    let nativeID = ~~data;
+
+    let actor = this._getActorByNativeID(nativeID);
+
+    // If actorID exists, emit; in the case where we get demise
+    // notifications for a document that no longer exists,
+    // the mapping should not be found, so we do not emit an event.
+    if (actor) {
+      this._nativeToActorID.delete(nativeID);
+      emit(this, "destroy-node", actor);
+    }
+  },
+
+  /**
+   * Called when the underlying ContentObserver fires `global-destroyed`
+   * so we can cleanup some things between the global being destroyed and
+   * when the actor's `finalize` method gets called.
+   */
+  _onGlobalDestroyed: function (id) {
+    if (this._callWatcher._tracedWindowId !== id) {
+      return;
+    }
+
+    if (this._nativeToActorID) {
+      this._nativeToActorID.clear();
+    }
+    systemOff("webaudio-node-demise", this._onDestroyNode);
+  },
+
 });
 
 /**
  * The corresponding Front object for the WebAudioActor.
  */
 let WebAudioFront = exports.WebAudioFront = protocol.FrontClass(WebAudioActor, {
   initialize: function(client, { webaudioActor }) {
     protocol.Front.prototype.initialize.call(this, client, { actor: webaudioActor });
@@ -526,22 +596,23 @@ function constructError (err) {
   return {
     message: err.message,
     type: err.constructor.name
   };
 }
 
 /**
  * Takes an object and converts it's `toString()` form, like
- * "[object OscillatorNode]" or "[object Float32Array]"
+ * "[object OscillatorNode]" or "[object Float32Array]",
+ * or XrayWrapper objects like "[object XrayWrapper [object Array]]"
  * to a string of just the constructor name, like "OscillatorNode",
  * or "Float32Array".
  */
 function getConstructorName (obj) {
-  return obj.toString().match(/\[object (.*)\]$/)[1];
+  return obj.toString().match(/\[object ([^\[\]]*)\]\]?$/)[1];
 }
 
 /**
  * Create a grip-like object to pass in renderable information
  * to the front-end for things like Float32Arrays, AudioBuffers,
  * without tracking them in an actor pool.
  */
 function createObjectGrip (value) {
@@ -552,8 +623,12 @@ function createObjectGrip (value) {
       text: ""
     },
     class: getConstructorName(value)
   };
 }
 function unwrap (obj) {
   return XPCNativeWrapper.unwrap(obj);
 }
+
+function wrap (obj) {
+  return new XPCNativeWrapper(obj);
+}
-- 
1.8.4.2

