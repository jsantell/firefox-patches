From: Jordan Santell <jsantell@mozilla.com>
Date: Mon, 4 May 2015 12:16:32 -0700
Subject: [PATCH 1/2] Bug 1145187

diff --git a/browser/devtools/performance/modules/actors.js b/browser/devtools/performance/modules/actors.js
index 61fec66..3f15357 100644
--- a/browser/devtools/performance/modules/actors.js
+++ b/browser/devtools/performance/modules/actors.js
@@ -14,24 +14,27 @@ const {
 loader.lazyRequireGetter(this, "EventEmitter",
   "devtools/toolkit/event-emitter");
 loader.lazyRequireGetter(this, "RecordingUtils",
   "devtools/performance/recording-utils", true);
 loader.lazyRequireGetter(this, "TimelineFront",
   "devtools/server/actors/timeline", true);
 loader.lazyRequireGetter(this, "MemoryFront",
   "devtools/server/actors/memory", true);
-loader.lazyRequireGetter(this, "timers",
-  "resource://gre/modules/Timer.jsm");
+loader.lazyRequireGetter(this, "Poller",
+  "devtools/shared/poller", true);
 
 // how often do we pull allocation sites from the memory actor
 const ALLOCATION_SITE_POLL_TIMER = 200; // ms
 
+// how often do we check the status of the profiler's circular buffer
+const BUFFER_CHECK_TIMER = 5000; // ms
+
 const MEMORY_ACTOR_METHODS = [
-  "destroy", "attach", "detach", "getState", "getAllocationsSettings",
+  "attach", "detach", "getState", "getAllocationsSettings",
   "getAllocations", "startRecordingAllocations", "stopRecordingAllocations"
 ];
 
 const TIMELINE_ACTOR_METHODS = [
   "start", "stop",
 ];
 
 const PROFILER_ACTOR_METHODS = [
@@ -40,89 +43,130 @@ const PROFILER_ACTOR_METHODS = [
 ];
 
 /**
  * Constructor for a facade around an underlying ProfilerFront.
  */
 function ProfilerFrontFacade (target) {
   this._target = target;
   this._onProfilerEvent = this._onProfilerEvent.bind(this);
+  this._checkBufferStatus = this._checkBufferStatus.bind(this);
+  this._BUFFER_CHECK_TIMER = this._target.TEST_MOCK_BUFFER_CHECK_TIMER || BUFFER_CHECK_TIMER;
+
   EventEmitter.decorate(this);
 }
 
 ProfilerFrontFacade.prototype = {
   EVENTS: ["console-api-profiler", "profiler-stopped"],
 
   // Connects to the targets underlying real ProfilerFront.
   connect: Task.async(function*() {
     let target = this._target;
     this._actor = yield getProfiler(target);
 
     // Fetch and store information about the SPS profiler and
     // server profiler.
     this.traits = {};
     this.traits.filterable = target.getTrait("profilerDataFilterable");
+    this.traits.bufferStatus = target.getTrait("profilerBufferStatus");
 
     // Directly register to event notifications when connected
     // to hook into `console.profile|profileEnd` calls.
     yield this.registerEventNotifications({ events: this.EVENTS });
     // TODO bug 1159389, listen directly to actor if supporting new front
     target.client.addListener("eventNotification", this._onProfilerEvent);
   }),
 
   /**
    * Unregisters events for the underlying profiler actor.
    */
   destroy: Task.async(function *() {
+    if (this._poller) {
+      yield this._poller.destroy();
+    }
     yield this.unregisterEventNotifications({ events: this.EVENTS });
     // TODO bug 1159389, listen directly to actor if supporting new front
     this._target.client.removeListener("eventNotification", this._onProfilerEvent);
   }),
 
   /**
    * Starts the profiler actor, if necessary.
+   *
+   * @option {number?} bufferSize
+   * @option {number?} sampleFrequency
    */
   start: Task.async(function *(options={}) {
+    // Check for poller status even if the profiler is already active --
+    // profiler can be activated via `console.profile` or another source, like
+    // the Gecko Profiler.
+    if (!this._poller) {
+      this._poller = new Poller(this._checkBufferStatus, this._BUFFER_CHECK_TIMER, false);
+    }
+    if (!this._poller.isPolling()) {
+      this._poller.on();
+    }
+
     // Start the profiler only if it wasn't already active. The built-in
     // nsIPerformance module will be kept recording, because it's the same instance
     // for all targets and interacts with the whole platform, so we don't want
     // to affect other clients by stopping (or restarting) it.
     let profilerStatus = yield this.isActive();
     if (profilerStatus.isActive) {
+      // Get the buffer status at the starting point
+      let bufferStatus = yield this.getBufferInfo();
+
       this.emit("profiler-already-active");
-      return profilerStatus.currentTime;
+      return { startTime: profilerStatus.currentTime, bufferStatus };
     }
 
     // Translate options from the recording model into profiler-specific
     // options for the nsIProfiler
     let profilerOptions = {
       entries: options.bufferSize,
       interval: options.sampleFrequency ? (1000 / (options.sampleFrequency * 1000)) : void 0
     };
 
     yield this.startProfiler(profilerOptions);
+    // Get the buffer status at the starting point
+    let bufferStatus = yield this.getBufferInfo();
 
     this.emit("profiler-activated");
-    return 0;
+    return { startTime: 0, bufferStatus };
+  }),
+
+  /**
+   * Indicates the end of a recording -- does not actually stop the profiler
+   * (stopProfiler does that), but notes that we no longer need to poll
+   * for buffer status.
+   */
+  stop: Task.async(function *() {
+    yield this._poller.off();
   }),
 
   /**
    * Returns profile data from now since `startTime`.
    */
   getProfile: Task.async(function *(options) {
     let profilerData = yield (actorCompatibilityBridge("getProfile").call(this, options));
     // If the backend does not support filtering by start and endtime on platform (< Fx40),
     // do it on the client (much slower).
     if (!this.traits.filterable) {
       RecordingUtils.filterSamples(profilerData.profile, options.startTime || 0);
     }
 
     return profilerData;
   }),
 
+  getBufferInfo: Task.async(function *() {
+    if (!this.traits.bufferStatus) {
+      return null;
+    }
+    return (yield actorCompatibilityBridge("getBufferInfo").call(this));
+  }),
+
   /**
    * Invoked whenever a registered event was emitted by the profiler actor.
    *
    * @param object response
    *        The data received from the backend.
    */
   _onProfilerEvent: function (_, { topic, subject, details }) {
     if (topic === "console-api-profiler") {
@@ -131,16 +175,20 @@ ProfilerFrontFacade.prototype = {
       } else if (subject.action === "profileEnd") {
         this.emit("console-profile-end", details);
       }
     } else if (topic === "profiler-stopped") {
       this.emit("profiler-stopped");
     }
   },
 
+  _checkBufferStatus: Task.async(function *() {
+    this.emit("buffer-status", (yield this.getBufferInfo()));
+  }),
+
   toString: () => "[object ProfilerFrontFacade]"
 };
 
 // Bind all the methods that directly proxy to the actor
 PROFILER_ACTOR_METHODS.forEach(method => ProfilerFrontFacade.prototype[method] = actorCompatibilityBridge(method));
 exports.ProfilerFront = ProfilerFrontFacade;
 
 /**
@@ -195,45 +243,61 @@ TIMELINE_ACTOR_METHODS.forEach(method => TimelineFrontFacade.prototype[method] =
 exports.TimelineFront = TimelineFrontFacade;
 
 /**
  * Constructor for a facade around an underlying ProfilerFront.
  */
 function MemoryFrontFacade (target) {
   this._target = target;
   this._pullAllocationSites = this._pullAllocationSites.bind(this);
+
   EventEmitter.decorate(this);
 }
 
 MemoryFrontFacade.prototype = {
   connect: Task.async(function*() {
     let supported = yield memoryActorSupported(this._target);
     this._actor = supported ?
                   new MemoryFront(this._target.client, this._target.form) :
                   new MockMemoryFront();
 
     this.IS_MOCK = !supported;
   }),
 
   /**
+   * Disables polling and destroys actor.
+   */
+  destroy: Task.async(function *() {
+    if (this._poller) {
+      yield this._poller.destroy();
+    }
+    yield this._actor.destroy();
+  }),
+
+  /**
    * Starts polling for allocation information.
    */
   start: Task.async(function *(options) {
     if (!options.withAllocations) {
       return 0;
     }
 
     yield this.attach();
 
     let startTime = yield this.startRecordingAllocations({
       probability: options.allocationsSampleProbability,
       maxLogLength: options.allocationsMaxLogLength
     });
 
-    yield this._pullAllocationSites();
+    if (!this._poller) {
+      this._poller = new Poller(this._pullAllocationSites, ALLOCATION_SITE_POLL_TIMER, false);
+    }
+    if (!this._poller.isPolling()) {
+      this._poller.on();
+    }
 
     return startTime;
   }),
 
   /**
    * Stops polling for allocation information.
    */
   stop: Task.async(function *(options) {
@@ -241,18 +305,18 @@ MemoryFrontFacade.prototype = {
       return 0;
     }
 
     // Since `_pullAllocationSites` is usually running inside a timeout, and
     // it's performing asynchronous requests to the server, a recording may
     // be stopped before that method finishes executing. Therefore, we need to
     // wait for the last request to `getAllocations` to finish before actually
     // stopping recording allocations.
+    yield this._poller.off();
     yield this._lastPullAllocationSitesFinished;
-    timers.clearTimeout(this._sitesPullTimeout);
 
     let endTime = yield this.stopRecordingAllocations();
     yield this.detach();
 
     return endTime;
   }),
 
   /**
@@ -275,18 +339,16 @@ MemoryFrontFacade.prototype = {
     // being the event name, and the second argument describing the type.
     this.emit("timeline-data", "allocations", {
       sites: memoryData.allocations,
       timestamps: memoryData.allocationsTimestamps,
       frames: memoryData.frames,
       counts: memoryData.counts
     });
 
-    this._sitesPullTimeout = timers.setTimeout(this._pullAllocationSites, ALLOCATION_SITE_POLL_TIMER);
-
     resolve();
   }),
 
   toString: () => "[object MemoryFrontFacade]"
 };
 
 // Bind all the methods that directly proxy to the actor
 MEMORY_ACTOR_METHODS.forEach(method => MemoryFrontFacade.prototype[method] = actorCompatibilityBridge(method));
diff --git a/browser/devtools/performance/modules/compatibility.js b/browser/devtools/performance/modules/compatibility.js
index fd79287..b34e77b 100644
--- a/browser/devtools/performance/modules/compatibility.js
+++ b/browser/devtools/performance/modules/compatibility.js
@@ -148,16 +148,23 @@ function legacyRequest (target, actor, method, args) {
 /**
  * Returns a function to be used as a method on an "Actor" in ./actors.
  * Calls the underlying actor's method, supporting the modern `Front`
  * interface if possible, otherwise, falling back to using
  * `legacyRequest`.
  */
 function actorCompatibilityBridge (method) {
   return function () {
+    // If there's no target or client on this actor facade,
+    // abort silently -- this occurs in tests when polling occurs
+    // after the test ends, when tests do not wait for toolbox destruction
+    // (which will destroy the actor facade, turning off the polling).
+    if (!this._target || !this._target.client) {
+      return;
+    }
     // Check to see if this is a modern ActorFront, which has its
     // own `request` method. Also, check if its a mock actor, as it mimicks
     // the ActorFront interface.
     // The profiler actor does not currently support the modern `Front`
     // interface, so we have to manually push packets to it.
     // TODO bug 1159389, fix up profiler actor to not need this, however
     // we will need it for backwards compat
     if (this.IS_MOCK || this._actor.request) {
diff --git a/browser/devtools/performance/modules/front.js b/browser/devtools/performance/modules/front.js
index 0ce6e83..df375b1 100644
--- a/browser/devtools/performance/modules/front.js
+++ b/browser/devtools/performance/modules/front.js
@@ -16,25 +16,21 @@ loader.lazyRequireGetter(this, "DevToolsUtils",
 loader.lazyRequireGetter(this, "actors",
   "devtools/performance/actors");
 
 loader.lazyImporter(this, "gDevTools",
   "resource:///modules/devtools/gDevTools.jsm");
 loader.lazyImporter(this, "Promise",
   "resource://gre/modules/Promise.jsm");
 
-
-// How often do we pull allocation sites from the memory actor.
-const DEFAULT_ALLOCATION_SITES_PULL_TIMEOUT = 200; // ms
-
 // Events to pipe from PerformanceActorsConnection to the PerformanceFront
 const CONNECTION_PIPE_EVENTS = [
   "console-profile-start", "console-profile-ending", "console-profile-end",
   "timeline-data", "profiler-already-active", "profiler-activated",
-  "recording-started", "recording-stopped"
+  "recording-started", "recording-stopped", "buffer-status"
 ];
 
 /**
  * A cache of all PerformanceActorsConnection instances.
  * The keys are Target objects.
  */
 let SharedPerformanceActors = new WeakMap();
 
@@ -75,16 +71,17 @@ function PerformanceActorsConnection(target) {
   this._pendingConsoleRecordings = [];
   this._sitesPullTimeout = 0;
   this._recordings = [];
 
   this._pipeToConnection = this._pipeToConnection.bind(this);
   this._onTimelineData = this._onTimelineData.bind(this);
   this._onConsoleProfileStart = this._onConsoleProfileStart.bind(this);
   this._onConsoleProfileEnd = this._onConsoleProfileEnd.bind(this);
+  this._onBufferStatus = this._onBufferStatus.bind(this);
   this._onProfilerUnexpectedlyStopped = this._onProfilerUnexpectedlyStopped.bind(this);
 
   Services.obs.notifyObservers(null, "performance-actors-connection-created", null);
 }
 
 PerformanceActorsConnection.prototype = {
 
   // Properties set based off of server actor support
@@ -169,29 +166,31 @@ PerformanceActorsConnection.prototype = {
   _registerListeners: function () {
     this._timeline.on("timeline-data", this._onTimelineData);
     this._memory.on("timeline-data", this._onTimelineData);
     this._profiler.on("console-profile-start", this._onConsoleProfileStart);
     this._profiler.on("console-profile-end", this._onConsoleProfileEnd);
     this._profiler.on("profiler-stopped", this._onProfilerUnexpectedlyStopped);
     this._profiler.on("profiler-already-active", this._pipeToConnection);
     this._profiler.on("profiler-activated", this._pipeToConnection);
+    this._profiler.on("buffer-status", this._onBufferStatus);
   },
 
   /**
    * Unregisters listeners on events on the underlying actors.
    */
   _unregisterListeners: function () {
     this._timeline.off("timeline-data", this._onTimelineData);
     this._memory.off("timeline-data", this._onTimelineData);
     this._profiler.off("console-profile-start", this._onConsoleProfileStart);
     this._profiler.off("console-profile-end", this._onConsoleProfileEnd);
     this._profiler.off("profiler-stopped", this._onProfilerUnexpectedlyStopped);
     this._profiler.off("profiler-already-active", this._pipeToConnection);
     this._profiler.off("profiler-activated", this._pipeToConnection);
+    this._profiler.off("buffer-status", this._onBufferStatus);
   },
 
   /**
    * Closes the connections to non-profiler actors.
    */
   _disconnectActors: Task.async(function* () {
     yield Promise.all([
       this._profiler.destroy(),
@@ -289,44 +288,57 @@ PerformanceActorsConnection.prototype = {
    * - frames
    * - memory
    * - ticks
    * - allocations
    *
    * Populate our internal store of recordings for all currently recording sessions.
    */
   _onTimelineData: function (_, ...data) {
-    this._recordings.forEach(e => e.addTimelineData.apply(e, data));
+    this._recordings.forEach(e => e._addTimelineData.apply(e, data));
     this.emit("timeline-data", ...data);
   },
 
   /**
+   * Called whenever the underlying profiler polls its buffer status.
+   */
+  _onBufferStatus: function (_, data) {
+    // If no buffer data emitted (whether from an older actor being destroyed
+    // from a previous test, or the server does not support it), just ignore.
+    if (!data) {
+      return;
+    }
+    this._recordings.forEach(e => e._addBufferStatusData.call(e, data));
+    this.emit("buffer-status", data);
+  },
+
+  /**
    * Begins a recording session
    *
    * @param object options
    *        An options object to pass to the actors. Supported properties are
    *        `withTicks`, `withMemory` and `withAllocations`, `probability`, and `maxLogLength`.
    * @return object
    *         A promise that is resolved once recording has started.
    */
   startRecording: Task.async(function*(options = {}) {
     let model = new RecordingModel(options);
     // All actors are started asynchronously over the remote debugging protocol.
     // Get the corresponding start times from each one of them.
     // The timeline and memory actors are target-dependent, so start those as well,
     // even though these are mocked in older Geckos (FF < 35)
-    let profilerStartTime = yield this._profiler.start(options);
+    let { startTime: profilerStartTime, bufferStatus } = yield this._profiler.start(options);
     let timelineStartTime = yield this._timeline.start(options);
     let memoryStartTime = yield this._memory.start(options);
 
-    let data = { profilerStartTime, timelineStartTime, memoryStartTime };
+    let data = { profilerStartTime, timelineStartTime, memoryStartTime, bufferStatus };
 
     // Signify to the model that the recording has started,
     // populate with data and store the recording model here.
-    model.populate(data);
+    model._populate(data);
     this._recordings.push(model);
 
     this.emit("recording-started", model);
     return model;
   }),
 
   /**
    * Manually ends the recording session for the corresponding RecordingModel.
@@ -359,16 +371,17 @@ PerformanceActorsConnection.prototype = {
     let memoryEndTime = Date.now();
     let timelineEndTime = Date.now();
 
     // Only if there are no more sessions recording do we stop
     // the underlying memory and timeline actors. If we're still recording,
     // juse use Date.now() for the memory and timeline end times, as those
     // are only used in tests.
     if (!this.isRecording()) {
+      yield this._profiler.stop();
       memoryEndTime = yield this._memory.stop(config);
       timelineEndTime = yield this._timeline.stop(config);
     }
 
     // Set the results on the RecordingModel itself.
     model._onStopRecording({
       // Data available only at the end of a recording.
       profile: profilerData.profile,
diff --git a/browser/devtools/performance/modules/recording-model.js b/browser/devtools/performance/modules/recording-model.js
index 6d92bc9..a9f92b1 100644
--- a/browser/devtools/performance/modules/recording-model.js
+++ b/browser/devtools/performance/modules/recording-model.js
@@ -37,16 +37,18 @@ RecordingModel.prototype = {
   // Private fields, only needed when a recording is started or stopped.
   _console: false,
   _imported: false,
   _recording: false,
   _profilerStartTime: 0,
   _timelineStartTime: 0,
   _memoryStartTime: 0,
   _configuration: {},
+  _originalBufferStatus: null,
+  _bufferPercent: null,
 
   // Serializable fields, necessary and sufficient for import and export.
   _label: "",
   _duration: 0,
   _markers: null,
   _frames: null,
   _memory: null,
   _ticks: null,
@@ -84,26 +86,27 @@ RecordingModel.prototype = {
     let recordingData = this.getAllData();
     yield PerformanceIO.saveRecordingToFile(recordingData, file);
   }),
 
   /**
    * Sets up the instance with data from the SharedPerformanceConnection when
    * starting a recording. Should only be called by SharedPerformanceConnection.
    */
-  populate: function (info) {
+  _populate: function (info) {
     // Times must come from the actor in order to be self-consistent.
     // However, we also want to update the view with the elapsed time
     // even when the actor is not generating data. To do this we get
     // the local time and use it to compute a reasonable elapsed time.
     this._localStartTime = Date.now()
 
     this._profilerStartTime = info.profilerStartTime;
     this._timelineStartTime = info.timelineStartTime;
     this._memoryStartTime = info.memoryStartTime;
+    this._originalBufferStatus = info.bufferStatus;
     this._recording = true;
 
     this._markers = [];
     this._frames = [];
     this._memory = [];
     this._ticks = [];
     this._allocations = { sites: [], timestamps: [], frames: [], counts: [] };
   },
@@ -252,19 +255,45 @@ RecordingModel.prototype = {
    * Returns a boolean indicating whether or not this recording model
    * is recording.
    */
   isRecording: function () {
     return this._recording;
   },
 
   /**
+   * Returns the percent (value between 0 and 1) of buffer used in this
+   * recording. Returns `null` for recordings that are no longer recording.
+   */
+  getBufferUsage: function () {
+    return this.isRecording() ? this._bufferPercent : null;
+  },
+
+  /**
+   * Fired whenever the PerformanceFront has new buffer data.
+   */
+  _addBufferStatusData: function (bufferStatus) {
+    // If this model isn't currently recording, or if the server does not
+    // support buffer status (or if this fires after actors are being destroyed),
+    // ignore this information.
+    if (!bufferStatus || !this.isRecording()) {
+      return;
+    }
+    let { position: currentPosition, totalSize, generation: currentGeneration } = bufferStatus;
+    let { position: origPosition, generation: origGeneration } = this._originalBufferStatus;
+
+    let normalizedCurrent = (totalSize * (currentGeneration - origGeneration)) + currentPosition;
+    let percent = (normalizedCurrent - origPosition) / totalSize;
+    this._bufferPercent = percent > 1 ? 1 : percent;
+  },
+
+  /**
    * Fired whenever the PerformanceFront emits markers, memory or ticks.
    */
-  addTimelineData: function (eventName, ...data) {
+  _addTimelineData: function (eventName, ...data) {
     // If this model isn't currently recording,
     // ignore the timeline data.
     if (!this._recording) {
       return;
     }
 
     let config = this.getConfiguration();
 
@@ -314,12 +343,14 @@ RecordingModel.prototype = {
         RecordingUtils.offsetAndScaleTimestamps(timestamps, timeOffset, timeScale);
         Array.prototype.push.apply(this._allocations.sites, sites);
         Array.prototype.push.apply(this._allocations.timestamps, timestamps);
         Array.prototype.push.apply(this._allocations.frames, frames);
         Array.prototype.push.apply(this._allocations.counts, counts);
         break;
       }
     }
-  }
+  },
+
+  toString: () => "[object RecordingModel]"
 };
 
 exports.RecordingModel = RecordingModel;
diff --git a/browser/devtools/performance/test/browser.ini b/browser/devtools/performance/test/browser.ini
index e6d160b..6f0687d 100644
--- a/browser/devtools/performance/test/browser.ini
+++ b/browser/devtools/performance/test/browser.ini
@@ -14,16 +14,17 @@ support-files =
 [browser_markers-gc.js]
 [browser_markers-parse-html.js]
 [browser_perf-allocations-to-samples.js]
 [browser_perf-compatibility-01.js]
 [browser_perf-compatibility-02.js]
 [browser_perf-compatibility-03.js]
 [browser_perf-compatibility-04.js]
 [browser_perf-compatibility-05.js]
+[browser_perf-compatibility-06.js]
 [browser_perf-clear-01.js]
 [browser_perf-clear-02.js]
 [browser_perf-columns-js-calltree.js]
 [browser_perf-columns-memory-calltree.js]
 [browser_perf-console-record-01.js]
 [browser_perf-console-record-02.js]
 [browser_perf-console-record-03.js]
 [browser_perf-console-record-04.js]
@@ -84,16 +85,17 @@ support-files =
 [browser_perf-overview-selection-02.js]
 [browser_perf-overview-selection-03.js]
 [browser_perf-overview-time-interval.js]
 [browser_perf-shared-connection-02.js]
 [browser_perf-shared-connection-03.js]
 [browser_perf-states.js]
 [browser_perf-refresh.js]
 [browser_perf-ui-recording.js]
+[browser_perf-recording-model-02.js]
 [browser_perf-recording-notices-01.js]
 [browser_perf-recording-notices-02.js]
 [browser_perf_recordings-io-01.js]
 [browser_perf_recordings-io-02.js]
 [browser_perf_recordings-io-03.js]
 [browser_perf_recordings-io-04.js]
 [browser_perf-range-changed-render.js]
 [browser_perf-recording-selected-01.js]
diff --git a/browser/devtools/performance/test/browser_perf-compatibility-06.js b/browser/devtools/performance/test/browser_perf-compatibility-06.js
new file mode 100644
index 0000000..2a6d0fe
--- /dev/null
+++ b/browser/devtools/performance/test/browser_perf-compatibility-06.js
@@ -0,0 +1,35 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+/**
+ * Tests that when using an older server (< Fx40) where the profiler actor does not
+ * have the `getBufferInfo` method that nothing breaks and RecordingModels have null
+ * `getBufferUsage()` values.
+ */
+
+function spawnTest () {
+  let { target, front } = yield initBackend(SIMPLE_URL, { TEST_MOCK_BUFFER_CHECK_TIMER: 10 });
+  let frontBufferStatusCalled = false;
+
+  // Explicitly override the profiler's trait `bufferStatus`
+  front._connection._profiler.traits.bufferStatus = false;
+
+  front.on("buffer-status", () => frontBufferStatusCalled = true);
+  let model = yield front.startRecording();
+  let [_, stats] = yield onceSpread(front._connection._profiler, "buffer-status");
+  is(stats, null, "buffer-status from profiler should emit `null`");
+
+  let count = 0;
+  while (count < 5) {
+    yield once(front._connection._profiler, "buffer-status");
+    count++;
+  }
+
+  is(model.getBufferUsage(), null, "model should have `null` for its buffer usage");
+  yield front.stopRecording(model);
+  is(model.getBufferUsage(), null, "after recording, model should still have `null` for its buffer usage");
+  ok(!frontBufferStatusCalled, "the front should never emit a buffer-status event when not supported.");
+
+  yield removeTab(target.tab);
+  finish();
+}
diff --git a/browser/devtools/performance/test/browser_perf-recording-model-02.js b/browser/devtools/performance/test/browser_perf-recording-model-02.js
new file mode 100644
index 0000000..4749a54
--- /dev/null
+++ b/browser/devtools/performance/test/browser_perf-recording-model-02.js
@@ -0,0 +1,41 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+/**
+ * Test that buffer status is correctly updated in recording models.
+ */
+
+let BUFFER_SIZE = 20000;
+
+function spawnTest () {
+  let { target, front } = yield initBackend(SIMPLE_URL, { TEST_MOCK_BUFFER_CHECK_TIMER: 10 });
+  let config = { bufferSize: BUFFER_SIZE };
+
+  let model = yield front.startRecording(config);
+  let [_, stats] = yield onceSpread(front, "buffer-status");
+  is(stats.totalSize, BUFFER_SIZE, `buffer-status event has correct totalSize: ${stats.totalSize}`);
+  ok(stats.position < BUFFER_SIZE, `buffer-status event has correct position: ${stats.position}`);
+  is(stats.generation, 0, `buffer-status event has correct generation: ${stats.generation}`);
+
+  // Halt once more for a buffer status to ensure we're beyond 0
+  yield once(front, "buffer-status");
+
+  let lastBufferStatus = 0;
+  let checkCount = 0;
+  while (lastBufferStatus < 1) {
+    let currentBufferStatus = model.getBufferUsage();
+    ok(currentBufferStatus > lastBufferStatus, `buffer is more filled than before: ${currentBufferStatus}`);
+    lastBufferStatus = currentBufferStatus;
+    checkCount++;
+    yield once(front, "buffer-status");
+  }
+
+  ok(checkCount > 2, "atleast 3 events were fired until the buffer was filled");
+  is(lastBufferStatus, 1, "buffer usage cannot surpass 100%");
+  yield front.stopRecording(model);
+
+  is(model.getBufferUsage(), null, "getBufferUsage() should be null when no longer recording.");
+
+  yield removeTab(target.tab);
+  finish();
+}
diff --git a/browser/devtools/performance/test/head.js b/browser/devtools/performance/test/head.js
index 871d2b1..ec0032a 100644
--- a/browser/devtools/performance/test/head.js
+++ b/browser/devtools/performance/test/head.js
@@ -189,16 +189,17 @@ function initBackend(aUrl, targetOps={}) {
 
     yield target.makeRemote();
 
     // Attach addition options to `target`. This is used to force mock fronts
     // to smokescreen test different servers where memory or timeline actors
     // may not exist. Possible options that will actually work:
     // TEST_MOCK_MEMORY_ACTOR = true
     // TEST_MOCK_TIMELINE_ACTOR = true
+    // TEST_MOCK_BUFFER_CHECK_TIMER = number
     merge(target, targetOps);
 
     let connection = getPerformanceActorsConnection(target);
     yield connection.open();
 
     let front = new PerformanceFront(connection);
     return { target, front };
   });
-- 
2.2.1


From 9f36b0e50236d31bcee260f958cda4f600260714 Mon Sep 17 00:00:00 2001
From: Jordan Santell <jsantell@mozilla.com>
Date: Mon, 4 May 2015 12:17:13 -0700
Subject: [PATCH 2/2] all

---
 browser/devtools/shared/moz.build                  |   1 +
 browser/devtools/shared/poller.js                  | 115 ++++++++++++++++++
 browser/devtools/shared/test/browser.ini           |   1 +
 browser/devtools/shared/test/browser_poller.js     | 131 +++++++++++++++++++++
 browser/devtools/shared/test/head.js               |  21 ++++
 toolkit/devtools/server/actors/profiler.js         |  11 ++
 toolkit/devtools/server/actors/root.js             |   3 +
 .../tests/unit/test_profiler_getbufferinfo.js      | 107 +++++++++++++++++
 toolkit/devtools/server/tests/unit/xpcshell.ini    |   1 +
 9 files changed, 391 insertions(+)
 create mode 100644 browser/devtools/shared/poller.js
 create mode 100644 browser/devtools/shared/test/browser_poller.js
 create mode 100644 toolkit/devtools/server/tests/unit/test_profiler_getbufferinfo.js

diff --git a/browser/devtools/shared/moz.build b/browser/devtools/shared/moz.build
index f6bc389..9f473be 100644
--- a/browser/devtools/shared/moz.build
+++ b/browser/devtools/shared/moz.build
@@ -50,16 +50,17 @@ EXTRA_JS_MODULES.devtools.shared += [
     'devices.js',
     'doorhanger.js',
     'frame-script-utils.js',
     'getjson.js',
     'inplace-editor.js',
     'node-attribute-parser.js',
     'observable-object.js',
     'options-view.js',
+    'poller.js',
     'source-utils.js',
     'telemetry.js',
     'theme-switching.js',
     'theme.js',
     'undo.js',
 ]
 
 EXTRA_JS_MODULES.devtools.shared.widgets += [
diff --git a/browser/devtools/shared/poller.js b/browser/devtools/shared/poller.js
new file mode 100644
index 0000000..6a773f5
--- /dev/null
+++ b/browser/devtools/shared/poller.js
@@ -0,0 +1,115 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+loader.lazyRequireGetter(this, "timers",
+  "resource://gre/modules/Timer.jsm");
+loader.lazyRequireGetter(this, "defer",
+  "sdk/core/promise", true);
+
+/**
+ * @constructor Poller
+ * Takes a function that is to be called on an interval,
+ * and can be turned on and off via methods to execute `fn` on the interval
+ * specified during `on`. If `fn` returns a promise, the polling waits for
+ * that promise to resolve before waiting the interval to call again.
+ *
+ * Specify the `wait` duration between polling here, and optionally
+ * an `immediate` boolean, indicating whether the function should be called
+ * immediately when toggling on.
+ *
+ * @param {function} fn
+ * @param {number} wait
+ * @param {boolean?} immediate
+ */
+function Poller (fn, wait, immediate) {
+  this._fn = fn;
+  this._wait = wait;
+  this._immediate = immediate;
+  this._poll = this._poll.bind(this);
+  this._preparePoll = this._preparePoll.bind(this);
+}
+exports.Poller = Poller;
+
+/**
+ * Returns a boolean indicating whether or not poller
+ * is polling.
+ *
+ * @return {boolean}
+ */
+Poller.prototype.isPolling = function pollerIsPolling () {
+  return !!this._timer;
+};
+
+/**
+ * Turns polling on.
+ *
+ * @return {Poller}
+ */
+Poller.prototype.on = function pollerOn () {
+  if (this._destroyed) {
+    throw Error("Poller cannot be turned on after destruction.");
+  }
+  if (this._timer) {
+    this.off();
+  }
+  this._immediate ? this._poll() : this._preparePoll();
+  return this;
+};
+
+/**
+ * Turns off polling. Returns a promise that resolves when
+ * the last outstanding `fn` call finishes if it's an async function.
+ *
+ * @return {Promise}
+ */
+Poller.prototype.off = function pollerOff () {
+  let { resolve, promise } = defer();
+  if (this._timer) {
+    timers.clearTimeout(this._timer);
+    this._timer = null;
+  }
+
+  // Settle an inflight poll call before resolving
+  // if using a promise-backed poll function
+  if (this._inflight) {
+    this._inflight.then(resolve);
+  } else {
+    resolve();
+  }
+  return promise;
+};
+
+/**
+ * Turns off polling and removes the reference to the poller function.
+ * Resolves when the last outstanding `fn` call finishes if it's an async function.
+ */
+Poller.prototype.destroy = function pollerDestroy () {
+  return this.off().then(() => {
+    this._destroyed = true;
+    this._fn = null
+  });
+};
+
+Poller.prototype._preparePoll = function pollerPrepare () {
+  this._timer = timers.setTimeout(this._poll, this._wait);
+};
+
+Poller.prototype._poll = function pollerPoll () {
+  let response = this._fn();
+  if (response && typeof response.then === "function") {
+    // Store the most recent in-flight polling
+    // call so we can clean it up when disabling
+    this._inflight = response;
+    response.then(() => {
+      // Only queue up the next call if poller was not turned off
+      // while this async poll call was in flight.
+      if (this._timer) {
+        this._preparePoll();
+      }
+    });
+  } else {
+    this._preparePoll();
+  }
+};
diff --git a/browser/devtools/shared/test/browser.ini b/browser/devtools/shared/test/browser.ini
index 2d1bd5f..c7cf6c8 100644
--- a/browser/devtools/shared/test/browser.ini
+++ b/browser/devtools/shared/test/browser.ini
@@ -79,16 +79,17 @@ skip-if = e10s # Layouthelpers test should not run in a content page.
 skip-if = e10s # Layouthelpers test should not run in a content page.
 [browser_mdn-docs-01.js]
 [browser_mdn-docs-02.js]
 [browser_num-l10n.js]
 [browser_observableobject.js]
 [browser_options-view-01.js]
 [browser_outputparser.js]
 skip-if = e10s # Test intermittently fails with e10s. Bug 1124162.
+[browser_poller.js]
 [browser_prefs-01.js]
 [browser_prefs-02.js]
 [browser_require_basic.js]
 [browser_spectrum.js]
 [browser_theme.js]
 [browser_tableWidget_basic.js]
 [browser_tableWidget_keyboard_interaction.js]
 [browser_tableWidget_mouse_interaction.js]
diff --git a/browser/devtools/shared/test/browser_poller.js b/browser/devtools/shared/test/browser_poller.js
new file mode 100644
index 0000000..07230eb
--- /dev/null
+++ b/browser/devtools/shared/test/browser_poller.js
@@ -0,0 +1,131 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+// Tests the Poller class.
+
+const { Poller } = devtools.require("devtools/shared/poller");
+
+add_task(function* () {
+  let count1 = 0, count2 = 0, count3 = 0;
+
+  let poller1 = new Poller(function () {
+    count1++;
+  }, 1000000000, true);
+  let poller2 = new Poller(function () {
+    count2++;
+  }, 10);
+  let poller3 = new Poller(function () {
+    count3++;
+  }, 1000000000);
+
+  poller2.on();
+
+  ok(!poller1.isPolling(), "isPolling() returns false for an off poller");
+  ok(poller2.isPolling(), "isPolling() returns true for an on poller");
+
+  yield waitUntil(() => count2 > 10);
+
+  ok(count2 > 10, "poller that was turned on polled several times");
+  ok(count1 === 0, "poller that was never turned on never polled");
+
+  yield poller2.off();
+  let currentCount2 = count2;
+
+  poller1.on(); // Really high poll time!
+  poller3.on(); // Really high poll time!
+
+  yield waitUntil(() => count1 === 1);
+  ok(true, "Poller calls fn immediately when `immediate` is true");
+  ok(count3 === 0, "Poller does not call fn immediately when `immediate` is not set");
+
+  ok(count2 === currentCount2, "a turned off poller does not continue to poll");
+  yield poller2.off();
+  yield poller2.off();
+  yield poller2.off();
+  ok(true, "Poller.prototype.off() is idempotent");
+
+  // This should still have not polled a second time
+  is(count1, 1, "wait time works");
+
+  ok(poller1.isPolling(), "isPolling() returns true for an on poller");
+  ok(!poller2.isPolling(), "isPolling() returns false for an off poller");
+});
+
+add_task(function *() {
+  let count = -1;
+  // Create a poller that returns a promise.
+  // The promise is resolved asynchronously after adding 9 to the count, ensuring
+  // that on every poll, we have a multiple of 10.
+  let asyncPoller = new Poller(function () {
+    count++;
+    ok(!(count%10), `Async poller called with a multiple of 10: ${count}`);
+    return new Promise(function (resolve, reject) {
+      let add9 = 9;
+      let interval = setInterval(() => {
+        if (add9--) {
+          count++;
+        } else {
+          clearInterval(interval);
+          resolve();
+        }
+      }, 10);
+    });
+  });
+
+  asyncPoller.on(1);
+  yield waitUntil(() => count > 50);
+  yield asyncPoller.off();
+});
+
+add_task(function *() {
+  // Create a poller that returns a promise. This poll call
+  // is called immediately, and then subsequently turned off.
+  // The call to `off` should not resolve until the inflight call
+  // finishes.
+  let inflightFinished = null;
+  let pollCalls = 0;
+  let asyncPoller = new Poller(function () {
+    pollCalls++;
+    return new Promise(function (resolve, reject) {
+      setTimeout(() => {
+        inflightFinished = true;
+        resolve();
+      }, 1000);
+    });
+  }, 1, true);
+  asyncPoller.on();
+
+  yield asyncPoller.off();
+  ok(inflightFinished, "off() method does not resolve until remaining inflight poll calls finish");
+  is(pollCalls, 1, "should only be one poll call to occur before turning off polling");
+});
+
+add_task(function *() {
+  // Create a poller that returns a promise. This poll call
+  // is called immediately, and then subsequently turned off.
+  // The call to `off` should not resolve until the inflight call
+  // finishes.
+  let inflightFinished = null;
+  let pollCalls = 0;
+  let asyncPoller = new Poller(function () {
+    pollCalls++;
+    return new Promise(function (resolve, reject) {
+      setTimeout(() => {
+        inflightFinished = true;
+        resolve();
+      }, 1000);
+    });
+  }, 1, true);
+  asyncPoller.on();
+
+  yield asyncPoller.destroy();
+  ok(inflightFinished, "destroy() method does not resolve until remaining inflight poll calls finish");
+  is(pollCalls, 1, "should only be one poll call to occur before destroying polling");
+  
+  try {
+    asyncPoller.on();
+    ok(false, "Calling on() after destruction should throw");
+  } catch (e) {
+    ok(true, "Calling on() after destruction should throw");
+  }
+});
diff --git a/browser/devtools/shared/test/head.js b/browser/devtools/shared/test/head.js
index c4ded15..b15ce09 100644
--- a/browser/devtools/shared/test/head.js
+++ b/browser/devtools/shared/test/head.js
@@ -237,8 +237,29 @@ function* openAndCloseToolbox(nbOfTimes, usageTime, toolId) {
 
     // We use a timeout to check the toolbox's active time
     yield new Promise(resolve => setTimeout(resolve, usageTime));
 
     info("Closing toolbox " + (i + 1));
     yield gDevTools.closeToolbox(target);
   }
 }
+
+/**
+ * Waits until a predicate returns true.
+ *
+ * @param function predicate
+ *        Invoked once in a while until it returns true.
+ * @param number interval [optional]
+ *        How often the predicate is invoked, in milliseconds.
+ */
+function waitUntil(predicate, interval = 10) {
+  if (predicate()) {
+    return Promise.resolve(true);
+  }
+  return new Promise(resolve => {
+    setTimeout(function() {
+      waitUntil(predicate).then(() => resolve(true));
+    }, interval);
+  });
+}
+
+// EventUtils just doesn't work!
diff --git a/toolkit/devtools/server/actors/profiler.js b/toolkit/devtools/server/actors/profiler.js
index 346719a..380741e 100644
--- a/toolkit/devtools/server/actors/profiler.js
+++ b/toolkit/devtools/server/actors/profiler.js
@@ -54,16 +54,26 @@ ProfilerActor.prototype = {
    * Returns an array of feature strings, describing the profiler features
    * that are available on this platform. Can be called while the profiler
    * is stopped.
    */
   onGetFeatures: function() {
     return { features: nsIProfilerModule.GetFeatures([]) };
   },
 
+  onGetBufferInfo: function(request) {
+    let position = {}, totalSize = {}, generation = {};
+    nsIProfilerModule.GetBufferInfo(position, totalSize, generation);
+    return {
+      position: position.value,
+      totalSize: totalSize.value,
+      generation: generation.value
+    }
+  },
+
   /**
    * Returns the configuration used that was originally passed in to start up the
    * profiler. Used for tests, and does not account for others using nsIProfiler.
    */
   onGetStartOptions: function() {
     return this._profilerStartOptions || {};
   },
 
@@ -316,16 +326,17 @@ function checkProfilerConsumers() {
 
 /**
  * The request types this actor can handle.
  * At the moment there are two known users of the Profiler actor:
  * the devtools and the Gecko Profiler addon, which uses the debugger
  * protocol to get profiles from Fennec.
  */
 ProfilerActor.prototype.requestTypes = {
+  "getBufferInfo": ProfilerActor.prototype.onGetBufferInfo,
   "getFeatures": ProfilerActor.prototype.onGetFeatures,
   "startProfiler": ProfilerActor.prototype.onStartProfiler,
   "stopProfiler": ProfilerActor.prototype.onStopProfiler,
   "isActive": ProfilerActor.prototype.onIsActive,
   "getSharedLibraryInformation": ProfilerActor.prototype.onGetSharedLibraryInformation,
   "getProfile": ProfilerActor.prototype.onGetProfile,
   "registerEventNotifications": ProfilerActor.prototype.onRegisterEventNotifications,
   "unregisterEventNotifications": ProfilerActor.prototype.onUnregisterEventNotifications,
diff --git a/toolkit/devtools/server/actors/root.js b/toolkit/devtools/server/actors/root.js
index f1a971d..19f34e9 100644
--- a/toolkit/devtools/server/actors/root.js
+++ b/toolkit/devtools/server/actors/root.js
@@ -164,16 +164,19 @@ RootActor.prototype = {
     // no longer expose tab actors, but also that getProcess forbids
     // exposing actors for security reasons
     get allowChromeProcess() {
       return DebuggerServer.allowChromeProcess;
     },
     // Whether or not `getProfile()` supports specifying a `startTime`
     // and `endTime` to filter out samples. Fx40+
     profilerDataFilterable: true,
+    // Whether or not the profiler has a `getBufferInfo` method
+    // necessary as the profiler does not use the ActorFront class.
+    profilerBufferStatus: true,
   },
 
   /**
    * Return a 'hello' packet as specified by the Remote Debugging Protocol.
    */
   sayHello: function() {
     return {
       from: this.actorID,
diff --git a/toolkit/devtools/server/tests/unit/test_profiler_getbufferinfo.js b/toolkit/devtools/server/tests/unit/test_profiler_getbufferinfo.js
new file mode 100644
index 0000000..26d9e71
--- /dev/null
+++ b/toolkit/devtools/server/tests/unit/test_profiler_getbufferinfo.js
@@ -0,0 +1,107 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+/**
+ * Tests if the profiler actor returns its buffer status via getBufferInfo.
+ */
+
+const Profiler = Cc["@mozilla.org/tools/profiler;1"].getService(Ci.nsIProfiler);
+const INITIAL_WAIT_TIME = 100; // ms
+const MAX_WAIT_TIME = 20000; // ms
+const MAX_PROFILER_ENTRIES = 10000000;
+
+function run_test()
+{
+  get_chrome_actors((client, form) => {
+    let actor = form.profilerActor;
+    activate_profiler(client, actor, startTime => {
+      wait_for_samples(client, actor, () => {
+        check_buffer(client, actor, () => {
+          deactivate_profiler(client, actor, () => {
+            client.close(do_test_finished);
+          });
+        });
+      });
+    });
+  })
+
+  do_test_pending();
+}
+
+function check_buffer(client, actor, callback)
+{
+  client.request({ to: actor, type: "getBufferInfo" }, response => {
+    do_check_true(typeof response.position === "number");
+    do_check_true(typeof response.totalSize === "number");
+    do_check_true(typeof response.generation === "number");
+    do_check_true(response.position > 0 && response.position < response.totalSize);
+    do_check_true(response.totalSize === MAX_PROFILER_ENTRIES);
+    // There's no way we'll fill the buffer in this test.
+    do_check_true(response.generation === 0);
+
+    callback();
+  });
+}
+
+function activate_profiler(client, actor, callback)
+{
+  client.request({ to: actor, type: "startProfiler", entries: MAX_PROFILER_ENTRIES }, response => {
+    do_check_true(response.started);
+    client.request({ to: actor, type: "isActive" }, response => {
+      do_check_true(response.isActive);
+      callback(response.currentTime);
+    });
+  });
+}
+
+function deactivate_profiler(client, actor, callback)
+{
+  client.request({ to: actor, type: "stopProfiler" }, response => {
+    do_check_false(response.started);
+    client.request({ to: actor, type: "isActive" }, response => {
+      do_check_false(response.isActive);
+      callback();
+    });
+  });
+}
+
+function wait_for_samples(client, actor, callback)
+{
+  function attempt(delay)
+  {
+    // No idea why, but Components.stack.sourceLine returns null.
+    let funcLine = Components.stack.lineNumber - 3;
+
+    // Spin for the requested time, then take a sample.
+    let start = Date.now();
+    let stack;
+    do_print("Attempt: delay = " + delay);
+    while (Date.now() - start < delay) { stack = Components.stack; }
+    do_print("Attempt: finished waiting.");
+
+    client.request({ to: actor, type: "getProfile" }, response => {
+      // At this point, we may or may not have samples, depending on
+      // whether the spin loop above has given the profiler enough time
+      // to get started.
+      if (response.profile.threads[0].samples.length == 0) {
+        if (delay < MAX_WAIT_TIME) {
+          // Double the spin-wait time and try again.
+          do_print("Attempt: no samples, going around again.");
+          return attempt(delay * 2);
+        } else {
+          // We've waited long enough, so just fail.
+          do_print("Attempt: waited a long time, but no samples were collected.");
+          do_print("Giving up.");
+          do_check_true(false);
+          return;
+        }
+      }
+      callback();
+    });
+  }
+
+  // Start off with a 100 millisecond delay.
+  attempt(INITIAL_WAIT_TIME);
+}
diff --git a/toolkit/devtools/server/tests/unit/xpcshell.ini b/toolkit/devtools/server/tests/unit/xpcshell.ini
index 0880897..9ed7cf1 100644
--- a/toolkit/devtools/server/tests/unit/xpcshell.ini
+++ b/toolkit/devtools/server/tests/unit/xpcshell.ini
@@ -211,16 +211,17 @@ skip-if = toolkit == "gonk"
 reason = bug 820380
 [test_breakpoint-actor-map.js]
 [test_profiler_activation-01.js]
 [test_profiler_activation-02.js]
 [test_profiler_close.js]
 [test_profiler_data.js]
 [test_profiler_events-01.js]
 [test_profiler_events-02.js]
+[test_profiler_getbufferinfo.js]
 [test_profiler_getfeatures.js]
 [test_profiler_getsharedlibraryinformation.js]
 [test_unsafeDereference.js]
 [test_add_actors.js]
 [test_trace_actor-01.js]
 [test_trace_actor-02.js]
 [test_trace_actor-03.js]
 [test_trace_actor-04.js]
-- 
2.2.1

