From 0bf73e25f16acdb6a79be124d7f9ad613d9bc1c6 Mon Sep 17 00:00:00 2001
From: Jordan Santell <jsantell@mozilla.com>
Date: Tue, 2 Jun 2015 16:53:00 -0700
Subject: [PATCH] Bug 1131661

---
 .../performance/modules/widgets/marker-details.js  |  9 +++++
 .../chrome/browser/devtools/timeline.properties    |  1 +
 docshell/base/nsDocShell.cpp                       | 39 +++++++++++++++++-----
 dom/webidl/ProfileTimelineMarker.webidl            |  1 +
 layout/base/RestyleManager.cpp                     | 15 ++++++++-
 5 files changed, 55 insertions(+), 10 deletions(-)

diff --git a/browser/devtools/performance/modules/widgets/marker-details.js b/browser/devtools/performance/modules/widgets/marker-details.js
index a21ca45..fbff046 100644
--- a/browser/devtools/performance/modules/widgets/marker-details.js
+++ b/browser/devtools/performance/modules/widgets/marker-details.js
@@ -75,16 +75,25 @@ MarkerDetails.prototype = {
   render: function({ marker, frames }) {
     this.empty();
 
     let elements = [];
     elements.push(MarkerUtils.DOM.buildTitle(this._document, marker));
     elements.push(MarkerUtils.DOM.buildDuration(this._document, marker));
     MarkerUtils.DOM.buildFields(this._document, marker).forEach(f => elements.push(f));
 
+    console.log(marker);
+    if (marker.invalidation) {
+      console.log("MARKER INVALIDATION", marker.invalidation);
+      let type = marker.name === "Styles" ? "styleInvalidation" : "";
+      elements.push(MarkerUtils.DOM.buildStackTrace(this._document, {
+        frameIndex: marker.invalidation, frames, type
+      }));
+    }
+
     // Build a stack element -- and use the "startStack" label if
     // we have both a startStack and endStack.
     if (marker.stack) {
       let type = marker.endStack ? "startStack" : "stack";
       elements.push(MarkerUtils.DOM.buildStackTrace(this._document, {
         frameIndex: marker.stack, frames, type
       }));
     }
diff --git a/browser/locales/en-US/chrome/browser/devtools/timeline.properties b/browser/locales/en-US/chrome/browser/devtools/timeline.properties
index 77b745b..d720f3e 100644
--- a/browser/locales/en-US/chrome/browser/devtools/timeline.properties
+++ b/browser/locales/en-US/chrome/browser/devtools/timeline.properties
@@ -68,11 +68,12 @@ timeline.markerDetail.consoleTimerName=Timer Name:
 timeline.markerDetail.DOMEventType=Event Type:
 timeline.markerDetail.DOMEventPhase=Phase:
 timeline.markerDetail.DOMEventTargetPhase=Target
 timeline.markerDetail.DOMEventCapturingPhase=Capture
 timeline.markerDetail.DOMEventBubblingPhase=Bubbling
 timeline.markerDetail.stack=Stack:
 timeline.markerDetail.startStack=Stack at start:
 timeline.markerDetail.endStack=Stack at end:
+timeline.markerDetail.styleInvalidation=Style invalidated at:
 timeline.markerDetail.unknownFrame=<unknown location>
 timeline.markerDetail.asyncStack=(Async: %S)
 timeline.markerDetail.causeName=Cause:
diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
index 769bce8..5e4aa0e 100644
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -2971,39 +2971,54 @@ nsDocShell::PopProfileTimelineMarkers(
   SequenceRooter<mozilla::dom::ProfileTimelineMarker> rooter(
     aCx, &profileTimelineMarkers);
 
   // If we see an unpaired START, we keep it around for the next call
   // to PopProfileTimelineMarkers.  We store the kept START objects in
   // this array.
   nsTArray<UniquePtr<TimelineMarker>> keptMarkers;
 
+  JS::PersistentRooted<JSObject*> lastStyleInvalidation;
+
   for (uint32_t i = 0; i < mProfileTimelineMarkers.Length(); ++i) {
     UniquePtr<TimelineMarker>& startPayload = mProfileTimelineMarkers[i];
     const char* startMarkerName = startPayload->GetName();
 
     bool hasSeenPaintedLayer = false;
     bool isPaint = strcmp(startMarkerName, "Paint") == 0;
+    bool isStyles = strcmp(startMarkerName, "Styles") == 0;
 
     // If we are processing a Paint marker, we append information from
     // all the embedded Layer markers to this array.
     dom::Sequence<dom::ProfileTimelineLayerRect> layerRectangles;
 
     // If this is a TRACING_TIMESTAMP marker, there's no corresponding "end"
-    // marker, as it's a single unit of time, not a duration, create the final
-    // marker here.
+    // marker, as it's a single unit of time, not a duration. These are used
+    // in scenarios where we want to send a marker with the same start/end
+    // values, or use the stack capture for something else.
     if (startPayload->GetMetaData() == TRACING_TIMESTAMP) {
-      mozilla::dom::ProfileTimelineMarker* marker =
-        profileTimelineMarkers.AppendElement();
 
-      marker->mName = NS_ConvertUTF8toUTF16(startPayload->GetName());
-      marker->mStart = startPayload->GetTime();
-      marker->mEnd = startPayload->GetTime();
-      startPayload->AddDetails(aCx, *marker);
-      continue;
+      // In the Console's "TimeStamp" case, finalized the marker
+      // and send
+      if (strcmp(startMarkerName, "TimeStamp") == 0) {
+        mozilla::dom::ProfileTimelineMarker* marker =
+          profileTimelineMarkers.AppendElement();
+
+        marker->mName = NS_ConvertUTF8toUTF16(startPayload->GetName());
+        marker->mStart = startPayload->GetTime();
+        marker->mEnd = startPayload->GetTime();
+        startPayload->AddDetails(aCx, *marker);
+        continue;
+      }
+
+      // Otherwise, store the stack that will be used elsewhere.
+      if (strcmp(startMarkerName, "Styles::Invalidation") == 0) {
+        printf("Found Styles::Invalidation: %p\n", startPayload->GetStack());
+        lastStyleInvalidation = startPayload->GetStack();
+      }
     }
 
     if (startPayload->GetMetaData() == TRACING_INTERVAL_START) {
       bool hasSeenEnd = false;
 
       // DOM events can be nested, so we must take care when searching
       // for the matching end.  It doesn't hurt to apply this logic to
       // all event types.
@@ -3040,16 +3055,21 @@ nsDocShell::PopProfileTimelineMarkers(
 
               marker->mName = NS_ConvertUTF8toUTF16(startPayload->GetName());
               marker->mStart = startPayload->GetTime();
               marker->mEnd = endPayload->GetTime();
               marker->mStack = startPayload->GetStack();
               if (isPaint) {
                 marker->mRectangles.Construct(layerRectangles);
               }
+              if (isStyles) {
+                //printf("Assigning Styles::Invalidation: %p\n", lastStyleInvalidation);
+                marker->mInvalidation = lastStyleInvalidation;
+                lastStyleInvalidation = nullptr;
+              }
               startPayload->AddDetails(aCx, *marker);
               endPayload->AddDetails(aCx, *marker);
             }
 
             // We want the start to be dropped either way.
             hasSeenEnd = true;
 
             break;
@@ -3060,16 +3080,17 @@ nsDocShell::PopProfileTimelineMarkers(
       // If we did not see the corresponding END, keep the START.
       if (!hasSeenEnd) {
         keptMarkers.AppendElement(Move(mProfileTimelineMarkers[i]));
         mProfileTimelineMarkers.RemoveElementAt(i);
         --i;
       }
     }
   }
+  lastStyleInvalidation = nullptr;
 
   mProfileTimelineMarkers.SwapElements(keptMarkers);
 
   if (!ToJSValue(aCx, profileTimelineMarkers, aProfileTimelineMarkers)) {
     JS_ClearPendingException(aCx);
     return NS_ERROR_UNEXPECTED;
   }
 
diff --git a/dom/webidl/ProfileTimelineMarker.webidl b/dom/webidl/ProfileTimelineMarker.webidl
index e520b9f..ac28a1b 100644
--- a/dom/webidl/ProfileTimelineMarker.webidl
+++ b/dom/webidl/ProfileTimelineMarker.webidl
@@ -36,9 +36,10 @@ dictionary ProfileTimelineMarker {
   object? endStack = null;
   /* For DOMEvent markers.  */
   DOMString type;
   unsigned short eventPhase;
   /* For Paint markers.  */
   sequence<ProfileTimelineLayerRect> rectangles;
   /* For Style markers. */
   DOMString restyleHint;
+  object? invalidation = null;
 };
diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
index 525fdcf..685c953 100644
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -577,17 +577,17 @@ RestyleManager::StyleChangeReflow(nsIFrame* aFrame, nsChangeHint aHint)
 
   do {
     mPresContext->PresShell()->FrameNeedsReflow(aFrame, dirtyType, dirtyBits);
     aFrame = nsLayoutUtils::GetNextContinuationOrIBSplitSibling(aFrame);
   } while (aFrame);
 }
 
 void
-RestyleManager::AddSubtreeToOverflowTracker(nsIFrame* aFrame) 
+RestyleManager::AddSubtreeToOverflowTracker(nsIFrame* aFrame)
 {
   mOverflowChangedTracker.AddFrame(
       aFrame,
       OverflowChangedTracker::CHILDREN_CHANGED);
   nsIFrame::ChildListIterator lists(aFrame);
   for (; !lists.IsDone(); lists.Next()) {
     nsFrameList::Enumerator childFrames(lists.CurrentList());
     for (; !childFrames.AtEnd(); childFrames.Next()) {
@@ -1818,16 +1818,29 @@ RestyleManager::PostRestyleEventInternal(bool aForLazyConstruction)
   // Make sure we're not in a style refresh; if we are, we still have
   // a call to ProcessPendingRestyles coming and there's no need to
   // add ourselves as a refresh observer until then.
   bool inRefresh = !aForLazyConstruction && mInStyleRefresh;
   nsIPresShell* presShell = mPresContext->PresShell();
   if (!mObservingRefreshDriver && !inRefresh) {
     mObservingRefreshDriver = mPresContext->RefreshDriver()->
       AddStyleFlushObserver(presShell);
+
+    // Gather stack information on style invalidation reasons
+    // for ProfileTimelineMarkers. In nsDocShell::PopProfileTimelineMarkers,
+    // these stacks get attached to subsequent "Styles" markers as
+    // invalidation stacks.
+    nsDocShell* docShell = static_cast<nsDocShell*>(mPresContext->GetDocShell());
+    bool isTimelineRecording = false;
+    if (docShell) {
+      docShell->GetRecordProfileTimelineMarkers(&isTimelineRecording);
+    }
+    if (isTimelineRecording) {
+      docShell->AddProfileTimelineMarker("Styles::Invalidation", TRACING_TIMESTAMP);
+    }
   }
 
   // Unconditionally flag our document as needing a flush.  The other
   // option here would be a dedicated boolean to track whether we need
   // to do so (set here and unset in ProcessPendingRestyles).
   presShell->GetDocument()->SetNeedStyleFlush();
 }
 
-- 
2.2.1

