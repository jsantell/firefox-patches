From 58f24b1e34835a1ee9eb3527ce9bed306754397c Mon Sep 17 00:00:00 2001
From: Jordan Santell <jsantell@gmail.com>
Date: Thu, 8 Jan 2015 15:05:54 -0800
Subject: Bug 1119516 - Old profiler data can now be imported into new
 performance tool. r=vp

diff --git a/browser/devtools/performance/modules/io.js b/browser/devtools/performance/modules/io.js
index 7fe968b..2b7e65c 100644
--- a/browser/devtools/performance/modules/io.js
+++ b/browser/devtools/performance/modules/io.js
@@ -13,17 +13,18 @@ loader.lazyImporter(this, "FileUtils",
 loader.lazyImporter(this, "NetUtil",
   "resource://gre/modules/NetUtil.jsm");
 
 // This identifier string is used to tentatively ascertain whether or not
 // a JSON loaded from disk is actually something generated by this tool.
 // It isn't, of course, a definitive verification, but a Good Enoughâ„¢
 // approximation before continuing the import. Don't localize this.
 const PERF_TOOL_SERIALIZER_IDENTIFIER = "Recorded Performance Data";
-const PERF_TOOL_SERIALIZER_VERSION = 1;
+const PERF_TOOL_SERIALIZER_LEGACY_VERSION = 1;
+const PERF_TOOL_SERIALIZER_CURRENT_VERSION = 2;
 
 /**
  * Helpers for importing/exporting JSON.
  */
 let PerformanceIO = {
   /**
    * Gets a nsIScriptableUnicodeConverter instance with a default UTF-8 charset.
    * @return object
@@ -46,17 +47,17 @@ let PerformanceIO = {
    * @return object
    *         A promise that is resolved once streaming finishes, or rejected
    *         if there was an error.
    */
   saveRecordingToFile: function(recordingData, file) {
     let deferred = promise.defer();
 
     recordingData.fileType = PERF_TOOL_SERIALIZER_IDENTIFIER;
-    recordingData.version = PERF_TOOL_SERIALIZER_VERSION;
+    recordingData.version = PERF_TOOL_SERIALIZER_CURRENT_VERSION;
 
     let string = JSON.stringify(recordingData);
     let inputStream = this.getUnicodeConverter().convertToInputStream(string);
     let outputStream = FileUtils.openSafeFileOutputStream(file);
 
     NetUtil.asyncCopy(inputStream, outputStream, deferred.resolve);
     return deferred.promise;
   },
@@ -83,20 +84,69 @@ let PerformanceIO = {
       } catch (e) {
         deferred.reject(new Error("Could not read recording data file."));
         return;
       }
       if (recordingData.fileType != PERF_TOOL_SERIALIZER_IDENTIFIER) {
         deferred.reject(new Error("Unrecognized recording data file."));
         return;
       }
-      if (recordingData.version != PERF_TOOL_SERIALIZER_VERSION) {
+      if (!isValidSerializerVersion(recordingData.version)) {
         deferred.reject(new Error("Unsupported recording data file version."));
         return;
       }
+      if (recordingData.version === PERF_TOOL_SERIALIZER_LEGACY_VERSION) {
+        recordingData = convertLegacyData(recordingData);
+      }
       deferred.resolve(recordingData);
     });
 
     return deferred.promise;
   }
 };
 
 exports.PerformanceIO = PerformanceIO;
+
+/**
+ * Returns a boolean indicating whether or not the passed in `version`
+ * is supported by this serializer.
+ *
+ * @param number version
+ * @return boolean
+ */
+function isValidSerializerVersion (version) {
+  return !!~[
+    PERF_TOOL_SERIALIZER_LEGACY_VERSION,
+    PERF_TOOL_SERIALIZER_CURRENT_VERSION
+  ].indexOf(version);
+}
+
+
+/**
+ * Takes recording data (with version `1`, from the original profiler tool), and
+ * massages the data to be line with the current performance tool's property names
+ * and values.
+ *
+ * @param object legacyData
+ * @return object
+ */
+function convertLegacyData (legacyData) {
+  let { profilerData, ticksData, recordingDuration } = legacyData;
+
+  // The `profilerData` stays, and the previously unrecorded fields
+  // just are empty arrays.
+  let data = {
+    markers: [],
+    frames: [],
+    memory: [],
+    ticks: ticksData,
+    profilerData: profilerData,
+    // Data from the original profiler won't contain `interval` fields,
+    // but a recording duration, as well as the current time, which can be used
+    // to infer the interval startTime and endTime.
+    interval: {
+      startTime: profilerData.currentTime - recordingDuration,
+      endTime: profilerData.currentTime
+    }
+  };
+
+  return data;
+}
diff --git a/browser/devtools/performance/test/browser.ini b/browser/devtools/performance/test/browser.ini
index 2dced93..563985b 100644
--- a/browser/devtools/performance/test/browser.ini
+++ b/browser/devtools/performance/test/browser.ini
@@ -33,8 +33,9 @@ support-files =
 [browser_perf-overview-selection-03.js]
 [browser_perf-shared-connection-02.js]
 [browser_perf-shared-connection-03.js]
 # [browser_perf-shared-connection-04.js] bug 1077464
 [browser_perf-ui-recording.js]
 [browser_perf_recordings-io-01.js]
 [browser_perf_recordings-io-02.js]
 [browser_perf_recordings-io-03.js]
+[browser_perf_recordings-io-04.js]
diff --git a/browser/devtools/performance/test/browser_perf_recordings-io-04.js b/browser/devtools/performance/test/browser_perf_recordings-io-04.js
new file mode 100644
index 0000000..ba78ce4
--- /dev/null
+++ b/browser/devtools/performance/test/browser_perf_recordings-io-04.js
@@ -0,0 +1,90 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+/**
+ * Tests if the performance tool can import profiler data from the
+ * original profiler tool.
+ */
+
+let test = Task.async(function*() {
+  let { target, panel, toolbox } = yield initPerformance(SIMPLE_URL);
+  let { EVENTS, PerformanceController } = panel.panelWin;
+
+  yield startRecording(panel);
+  yield stopRecording(panel);
+
+  // Get data from the current profiler
+  let data = PerformanceController.getAllData();
+
+  // Create a structure from the data that mimics the old profiler's data.
+  // Different name for `ticks`, different way of storing time,
+  // and no memory, markers data.
+  let oldProfilerData = {
+    recordingDuration: data.interval.endTime - data.interval.startTime,
+    ticksData: data.ticks,
+    profilerData: data.profilerData,
+    fileType: "Recorded Performance Data",
+    version: 1
+  };
+
+  // Save recording as an old profiler data.
+  let file = FileUtils.getFile("TmpD", ["tmpprofile.json"]);
+  file.createUnique(Ci.nsIFile.NORMAL_FILE_TYPE, parseInt("666", 8));
+  yield asyncCopy(oldProfilerData, file);
+
+  // Import recording.
+
+  let rerendered = waitForWidgetsRendered(panel);
+  let imported = once(PerformanceController, EVENTS.RECORDING_IMPORTED);
+  yield PerformanceController.importRecording("", file);
+
+  yield imported;
+  ok(true, "The original profiler data appears to have been successfully imported.");
+
+  yield rerendered;
+  ok(true, "The imported data was re-rendered.");
+
+  // Verify imported recording.
+
+  let importedData = PerformanceController.getAllData();
+
+  is(importedData.startTime, data.startTime,
+    "The imported legacy data was successfully converted for the current tool (1).");
+  is(importedData.endTime, data.endTime,
+    "The imported legacy data was successfully converted for the current tool (2).");
+  is(importedData.markers.toSource(), [].toSource(),
+    "The imported legacy data was successfully converted for the current tool (3).");
+  is(importedData.memory.toSource(), [].toSource(),
+    "The imported legacy data was successfully converted for the current tool (4).");
+  is(importedData.ticks.toSource(), data.ticks.toSource(),
+    "The imported legacy data was successfully converted for the current tool (5).");
+  is(importedData.profilerData.toSource(), data.profilerData.toSource(),
+    "The imported legacy data was successfully converted for the current tool (6).");
+
+  yield teardown(panel);
+  finish();
+});
+
+function getUnicodeConverter() {
+  let className = "@mozilla.org/intl/scriptableunicodeconverter";
+  let converter = Cc[className].createInstance(Ci.nsIScriptableUnicodeConverter);
+  converter.charset = "UTF-8";
+  return converter;
+}
+
+function asyncCopy(data, file) {
+  let deferred = Promise.defer();
+
+  let string = JSON.stringify(data);
+  let inputStream = getUnicodeConverter().convertToInputStream(string);
+  let outputStream = FileUtils.openSafeFileOutputStream(file);
+
+  NetUtil.asyncCopy(inputStream, outputStream, status => {
+    if (!Components.isSuccessCode(status)) {
+      deferred.reject(new Error("Could not save data to file."));
+    }
+    deferred.resolve();
+  });
+
+  return deferred.promise;
+}
-- 
2.2.1

