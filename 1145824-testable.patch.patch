From 95df2cd6d431df56c51ca7e2f72fddb37514a5a2 Mon Sep 17 00:00:00 2001
From: Jordan Santell <jsantell@gmail.com>
Date: Fri, 17 Apr 2015 12:44:52 -0700
Subject: [PATCH 1/2] Bug 1145824 - Profiler actor and performance tools now
 handle passing in a startTime to filter out SPS profiles on platform rather
 than client. r=vp,fitzgen

---
 browser/devtools/framework/toolbox.js              | 13 ++--
 .../devtools/performance/modules/compatibility.js  | 71 ++++++++++++++++++++
 browser/devtools/performance/modules/front.js      | 64 ++++++++----------
 .../performance/modules/recording-model.js         | 16 +++--
 browser/devtools/performance/test/browser.ini      |  1 +
 .../test/browser_perf-compatibility-05.js          | 75 ++++++++++++++++++++++
 browser/devtools/webide/test/head.js               |  3 +
 toolkit/devtools/server/actors/profiler.js         | 73 +++++++--------------
 toolkit/devtools/server/actors/root.js             |  3 +
 .../server/tests/unit/test_profiler_data.js        | 10 +--
 10 files changed, 229 insertions(+), 100 deletions(-)
 create mode 100644 browser/devtools/performance/test/browser_perf-compatibility-05.js

diff --git a/browser/devtools/framework/toolbox.js b/browser/devtools/framework/toolbox.js
index 7e66b57..f34bfe3 100644
--- a/browser/devtools/framework/toolbox.js
+++ b/browser/devtools/framework/toolbox.js
@@ -375,21 +375,24 @@ Toolbox.prototype = {
       }
 
       yield promise.all([
         splitConsolePromise,
         buttonsPromise,
         framesPromise
       ]);
 
+      // Lazily connect to the profiler here and don't wait for it to complete,
+      // used to intercept console.profile calls before the performance tools are open.
       let profilerReady = this._connectProfiler();
 
-      // Only wait for the profiler initialization during tests. Otherwise,
-      // lazily load this. This is to intercept console.profile calls; the performance
-      // tools will explicitly wait for the connection opening when opened.
+      // However, while testing, we must wait for the performance connection to finish,
+      // as most tests shut down without waiting for a toolbox destruction event,
+      // resulting in the shared profiler connection being opened and closed
+      // outside of the test that originally opened the toolbox.
       if (gDevTools.testing) {
         yield profilerReady;
       }
 
       this.emit("ready");
     }.bind(this)).then(null, console.error.bind(console));
   },
 
@@ -1861,17 +1864,19 @@ Toolbox.prototype = {
     }
 
     yield this.getPerformanceActorsConnection().open();
     // Emit an event when connected, but don't wait on startup for this.
     this.emit("profiler-connected");
   }),
 
   /**
-   * Disconnects the underlying Performance Actor Connection.
+   * Disconnects the underlying Performance Actor Connection. If the connection
+   * has not finished initializing, as opening a toolbox does not wait,
+   * the performance connection destroy method will wait for it on its own.
    */
   _disconnectProfiler: Task.async(function*() {
     if (!this._performanceConnection) {
       return;
     }
     yield this._performanceConnection.destroy();
     this._performanceConnection = null;
   }),
diff --git a/browser/devtools/performance/modules/compatibility.js b/browser/devtools/performance/modules/compatibility.js
index d0352b5..2cf4fa3 100644
--- a/browser/devtools/performance/modules/compatibility.js
+++ b/browser/devtools/performance/modules/compatibility.js
@@ -1,22 +1,82 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 const { Task } = require("resource://gre/modules/Task.jsm");
+loader.lazyRequireGetter(this, "promise");
 loader.lazyRequireGetter(this, "EventEmitter",
   "devtools/toolkit/event-emitter");
+loader.lazyRequireGetter(this, "RecordingUtils",
+  "devtools/performance/recording-utils", true);
 
 const REQUIRED_MEMORY_ACTOR_METHODS = [
   "attach", "detach", "startRecordingAllocations", "stopRecordingAllocations", "getAllocations"
 ];
 
 /**
+ * Constructor for a facade around an underlying ProfilerFront.
+ */
+function ProfilerFront (target) {
+  this._target = target;
+}
+
+ProfilerFront.prototype = {
+  // Connects to the targets underlying real ProfilerFront.
+  connect: Task.async(function*() {
+    let target = this._target;
+    // Chrome and content process targets already have obtained a reference
+    // to the profiler tab actor. Use it immediately.
+    if (target.form && target.form.profilerActor) {
+      this._profiler = target.form.profilerActor;
+    }
+    // Check if we already have a grip to the `listTabs` response object
+    // and, if we do, use it to get to the profiler actor.
+    else if (target.root && target.root.profilerActor) {
+      this._profiler = target.root.profilerActor;
+    }
+    // Otherwise, call `listTabs`.
+    else {
+      this._profiler = (yield listTabs(target.client)).profilerActor;
+    }
+
+    // Fetch and store information about the SPS profiler and
+    // server profiler.
+    this.traits = {};
+    this.traits.filterable = target.getTrait("profilerDataFilterable");
+  }),
+
+  /**
+   * Makes a request to the underlying real profiler actor. Handles
+   * backwards compatibility differences based off of the features
+   * and traits of the actor.
+   */
+  _request: function (method, ...args) {
+    let deferred = promise.defer();
+    let data = args[0] || {};
+    data.to = this._profiler;
+    data.type = method;
+    this._target.client.request(data, res => {
+      // If the backend does not support filtering by start and endtime on platform (< Fx40),
+      // do it on the client (much slower).
+      if (method === "getProfile" && !this.traits.filterable) {
+        RecordingUtils.filterSamples(res.profile, data.startTime || 0);
+      }
+
+      deferred.resolve(res);
+    });
+    return deferred.promise;
+  }
+};
+
+exports.ProfilerFront = ProfilerFront;
+
+/**
  * A dummy front decorated with the provided methods.
  *
  * @param array blueprint
  *        A list of [funcName, retVal] describing the class.
  */
 function MockFront (blueprint) {
   EventEmitter.decorate(this);
 
@@ -102,8 +162,19 @@ function timelineActorSupported(target) {
   // instances where the timeline actor is not available.
   if (target.TEST_MOCK_TIMELINE_ACTOR) {
     return false;
   }
 
   return target.hasActor("timeline");
 }
 exports.timelineActorSupported = Task.async(timelineActorSupported);
+
+/**
+ * Returns a promise resolved with a listing of all the tabs in the
+ * provided thread client.
+ */
+function listTabs(client) {
+  let deferred = promise.defer();
+  client.listTabs(deferred.resolve);
+  return deferred.promise;
+}
+
diff --git a/browser/devtools/performance/modules/front.js b/browser/devtools/performance/modules/front.js
index a99a030..4a95102 100644
--- a/browser/devtools/performance/modules/front.js
+++ b/browser/devtools/performance/modules/front.js
@@ -139,44 +139,36 @@ PerformanceActorsConnection.prototype = {
     Services.obs.notifyObservers(null, "performance-actors-connection-opened", null);
   }),
 
   /**
    * Destroys this connection.
    */
   destroy: Task.async(function*() {
     if (this._connecting && !this._connected) {
-      console.warn("Attempting to destroy SharedPerformanceActorsConnection before initialization completion. If testing, ensure `gDevTools.testing` is set.");
+      yield this._connecting.promise;
+    } else if (!this._connected) {
+      return;
     }
 
     yield this._unregisterListeners();
     yield this._disconnectActors();
 
     this._memory = this._timeline = this._profiler = this._target = this._client = null;
     this._connected = false;
+    this._connecting = null;
   }),
 
   /**
-   * Initializes a connection to the profiler actor.
+   * Initializes a connection to the profiler actor. Uses a facade around the ProfilerFront
+   * for similarity to the other actors in the shared connection.
    */
   _connectProfilerActor: Task.async(function*() {
-    // Chrome and content process targets already have obtained a reference
-    // to the profiler tab actor. Use it immediately.
-    if (this._target.form && this._target.form.profilerActor) {
-      this._profiler = this._target.form.profilerActor;
-    }
-    // Check if we already have a grip to the `listTabs` response object
-    // and, if we do, use it to get to the profiler actor.
-    else if (this._target.root && this._target.root.profilerActor) {
-      this._profiler = this._target.root.profilerActor;
-    }
-    // Otherwise, call `listTabs`.
-    else {
-      this._profiler = (yield listTabs(this._client)).profilerActor;
-    }
+    this._profiler = new compatibility.ProfilerFront(this._target);
+    yield this._profiler.connect();
   }),
 
   /**
    * Initializes a connection to a timeline actor.
    */
   _connectTimelineActor: function() {
     let supported = yield compatibility.timelineActorSupported(this._target);
     if (supported) {
@@ -248,22 +240,17 @@ PerformanceActorsConnection.prototype = {
    * @param any args [optional]
    *        Additional data or arguments to send with the request.
    * @return object
    *         A promise resolved with the response once the request finishes.
    */
   _request: function(actor, method, ...args) {
     // Handle requests to the profiler actor.
     if (actor == "profiler") {
-      let deferred = promise.defer();
-      let data = args[0] || {};
-      data.to = this._profiler;
-      data.type = method;
-      this._client.request(data, deferred.resolve);
-      return deferred.promise;
+      return this._profiler._request(method, ...args);
     }
 
     // Handle requests to the timeline actor.
     if (actor == "timeline") {
       return this._timeline[method].apply(this._timeline, args);
     }
 
     // Handle requests to the memory actor.
@@ -326,30 +313,40 @@ PerformanceActorsConnection.prototype = {
     }));
 
     this.emit("console-profile-start", model);
   }),
 
   /**
    * Invoked whenever `console.profileEnd` is called.
    *
-   * @param object profilerData
-   *        The dump of data from the profiler triggered by this console.profileEnd call.
+   * @param string profileLabel
+   *        The provided string argument if available; undefined otherwise.
+   * @param number currentTime
+   *        The time (in milliseconds) when the call was made, relative to when
+   *        the nsIProfiler module was started.
    */
-  _onConsoleProfileEnd: Task.async(function *(profilerData) {
+  _onConsoleProfileEnd: Task.async(function *(data) {
+    // If no data, abort; can occur if profiler isn't running and we get a surprise
+    // call to console.profileEnd()
+    if (!data) {
+      return;
+    }
+    let { profileLabel, currentTime: endTime } = data;
+
     let pending = this._recordings.filter(r => r.isConsole() && r.isRecording());
     if (pending.length === 0) {
       return;
     }
 
     let model;
     // Try to find the corresponding `console.profile` call if
     // a label was used in profileEnd(). If no matches, abort.
-    if (profilerData.profileLabel) {
-      model = pending.find(e => e.getLabel() === profilerData.profileLabel);
+    if (profileLabel) {
+      model = pending.find(e => e.getLabel() === profileLabel);
     }
     // If no label supplied, pop off the most recent pending console recording
     else {
       model = pending[pending.length - 1];
     }
 
     // If `profileEnd()` was called with a label, and there are no matching
     // sessions, abort.
@@ -440,17 +437,18 @@ PerformanceActorsConnection.prototype = {
     // from the PerformanceFront or via `console-profile-end` event) and then
     // remove it from the internal store.
     //
     // In the case where a console.profile is generated via the console (so the tools are
     // open), we initialize the Performance tool so it can listen to those events.
     this._recordings.splice(this._recordings.indexOf(model), 1);
 
     let config = model.getConfiguration();
-    let profilerData = yield this._request("profiler", "getProfile");
+    let startTime = model.getProfilerStartTime();
+    let profilerData = yield this._request("profiler", "getProfile", { startTime });
     let memoryEndTime = Date.now();
     let timelineEndTime = Date.now();
 
     // Only if there are no more sessions recording do we stop
     // the underlying memory and timeline actors. If we're still recording,
     // juse use Date.now() for the memory and timeline end times, as those
     // are only used in tests.
     if (!this.isRecording()) {
@@ -663,26 +661,16 @@ PerformanceFront.prototype = {
     return {
       memory: this._usingMockMemory,
       timeline: this._usingMockTimeline
     };
   }
 };
 
 /**
- * Returns a promise resolved with a listing of all the tabs in the
- * provided thread client.
- */
-function listTabs(client) {
-  let deferred = promise.defer();
-  client.listTabs(deferred.resolve);
-  return deferred.promise;
-}
-
-/**
  * Creates an object of configurations based off of preferences for a RecordingModel.
  */
 function getRecordingModelPrefs () {
   return {
     withMemory: Services.prefs.getBoolPref("devtools.performance.ui.enable-memory"),
     withTicks: Services.prefs.getBoolPref("devtools.performance.ui.enable-framerate"),
     withAllocations: Services.prefs.getBoolPref("devtools.performance.ui.enable-memory"),
     allocationsSampleProbability: +Services.prefs.getCharPref("devtools.performance.memory.sample-probability"),
diff --git a/browser/devtools/performance/modules/recording-model.js b/browser/devtools/performance/modules/recording-model.js
index 2d5292b..c000267 100644
--- a/browser/devtools/performance/modules/recording-model.js
+++ b/browser/devtools/performance/modules/recording-model.js
@@ -108,28 +108,36 @@ RecordingModel.prototype = {
    * Sets results available from stopping a recording from SharedPerformanceConnection.
    * Should only be called by SharedPerformanceConnection.
    */
   _onStopRecording: Task.async(function *(info) {
     this._profile = info.profile;
     this._duration = info.profilerEndTime - this._profilerStartTime;
     this._recording = false;
 
-    // We'll need to filter out all samples that fall out of current profile's
-    // range since the profiler is continuously running. Because of this, sample
-    // times are not guaranteed to have a zero epoch, so offset the timestamps.
-    RecordingUtils.filterSamples(this._profile, this._profilerStartTime);
+    // We filter out all samples that fall out of current profile's range
+    // since the profiler is continuously running. Because of this, sample
+    // times are not guaranteed to have a zero epoch, so offset the
+    // timestamps.
     RecordingUtils.offsetSampleTimes(this._profile, this._profilerStartTime);
 
     // Markers need to be sorted ascending by time, to be properly displayed
     // in a waterfall view.
     this._markers = this._markers.sort((a, b) => (a.start > b.start));
   }),
 
   /**
+   * Gets the profile's start time.
+   * @return number
+   */
+  getProfilerStartTime: function () {
+    return this._profilerStartTime;
+  },
+
+  /**
    * Gets the profile's label, from `console.profile(LABEL)`.
    * @return string
    */
   getLabel: function () {
     return this._label;
   },
 
   /**
diff --git a/browser/devtools/performance/test/browser.ini b/browser/devtools/performance/test/browser.ini
index 9be9058..f66c00c 100644
--- a/browser/devtools/performance/test/browser.ini
+++ b/browser/devtools/performance/test/browser.ini
@@ -14,16 +14,17 @@ support-files =
 
 [browser_markers-parse-html.js]
 
 [browser_perf-allocations-to-samples.js]
 [browser_perf-compatibility-01.js]
 [browser_perf-compatibility-02.js]
 [browser_perf-compatibility-03.js]
 [browser_perf-compatibility-04.js]
+[browser_perf-compatibility-05.js]
 [browser_perf-clear-01.js]
 [browser_perf-clear-02.js]
 [browser_perf-columns-js-calltree.js]
 [browser_perf-columns-memory-calltree.js]
 [browser_perf-console-record-01.js]
 [browser_perf-console-record-02.js]
 [browser_perf-console-record-03.js]
 [browser_perf-console-record-04.js]
diff --git a/browser/devtools/performance/test/browser_perf-compatibility-05.js b/browser/devtools/performance/test/browser_perf-compatibility-05.js
new file mode 100644
index 0000000..66d9d63
--- /dev/null
+++ b/browser/devtools/performance/test/browser_perf-compatibility-05.js
@@ -0,0 +1,75 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+/**
+ * Tests that when using an older server (< Fx40) where the profiler actor does not
+ * have the `filterable` trait, the samples are filtered by time on the client, rather
+ * than the more performant platform code.
+ */
+
+const WAIT_TIME = 1000; // ms
+
+function spawnTest () {
+  let { panel } = yield initPerformance(SIMPLE_URL);
+  let { gFront: front, gTarget: target } = panel.panelWin;
+  let connection = getPerformanceActorsConnection(target);
+
+  // Explicitly override the profiler's trait `filterable`
+  connection._profiler.traits.filterable = false;
+
+  // Ugly, but we need to also not send the startTime to the server
+  // so we don't filter it both on the server and client
+  let request = target.client.request;
+  target.client.request = (data, res) => {
+    // Copy so we don't destructively change the request object, as we use
+    // the startTime on this object for filtering in the callback
+    let newData = merge({}, data, { startTime: void 0 });
+    request.call(target.client, newData, res);
+  };
+
+  // Perform the first recording...
+
+  let firstRecording = yield front.startRecording();
+  let firstRecordingStartTime = firstRecording._profilerStartTime;
+  info("Started profiling at: " + firstRecordingStartTime);
+
+  busyWait(WAIT_TIME); // allow the profiler module to sample some cpu activity
+
+  yield front.stopRecording(firstRecording);
+
+  is(firstRecordingStartTime, 0,
+    "The profiling start time should be 0 for the first recording.");
+  ok(firstRecording.getDuration() >= WAIT_TIME,
+    "The first recording duration is correct.");
+
+  // Perform the second recording...
+
+  let secondRecording = yield front.startRecording();
+  let secondRecordingStartTime = secondRecording._profilerStartTime;
+  info("Started profiling at: " + secondRecordingStartTime);
+
+  busyWait(WAIT_TIME); // allow the profiler module to sample more cpu activity
+
+  yield front.stopRecording(secondRecording);
+  let secondRecordingProfile = secondRecording.getProfile();
+  let secondRecordingSamples = secondRecordingProfile.threads[0].samples;
+
+  isnot(secondRecording._profilerStartTime, 0,
+    "The profiling start time should not be 0 on the second recording.");
+  ok(secondRecording.getDuration() >= WAIT_TIME,
+    "The second recording duration is correct.");
+
+  info("Second profile's first sample time: " + secondRecordingSamples[0].time);
+  ok(secondRecordingSamples[0].time < secondRecordingStartTime,
+    "The second recorded sample times were normalized.");
+  ok(secondRecordingSamples[0].time > 0,
+    "The second recorded sample times were normalized correctly.");
+  ok(!secondRecordingSamples.find(e => e.time + secondRecordingStartTime <= firstRecording.getDuration()),
+    "There should be no samples from the first recording in the second one, " +
+    "even though the total number of frames did not overflow.");
+
+  target.client.request = request;
+
+  yield teardown(panel);
+  finish();
+}
diff --git a/browser/devtools/webide/test/head.js b/browser/devtools/webide/test/head.js
index 71d6697..a6bc9f3 100644
--- a/browser/devtools/webide/test/head.js
+++ b/browser/devtools/webide/test/head.js
@@ -5,19 +5,21 @@
 
 const {utils: Cu, classes: Cc, interfaces: Ci} = Components;
 
 Cu.import('resource://gre/modules/Services.jsm');
 Cu.import("resource://gre/modules/FileUtils.jsm");
 Cu.import("resource://gre/modules/Task.jsm");
 
 const {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
+const {gDevTools} = Cu.import("resource:///modules/devtools/gDevTools.jsm", {});
 const {require} = devtools;
 const promise = require("promise");
 const {AppProjects} = require("devtools/app-manager/app-projects");
+gDevTools.testing = true;
 
 let TEST_BASE;
 if (window.location === "chrome://browser/content/browser.xul") {
   TEST_BASE = "chrome://mochitests/content/browser/browser/devtools/webide/test/";
 } else {
   TEST_BASE = "chrome://mochitests/content/chrome/browser/devtools/webide/test/";
 }
 
@@ -28,16 +30,17 @@ Services.prefs.setBoolPref("devtools.webide.enableRuntimeConfiguration", true);
 Services.prefs.setCharPref("devtools.webide.addonsURL", TEST_BASE + "addons/simulators.json");
 Services.prefs.setCharPref("devtools.webide.simulatorAddonsURL", TEST_BASE + "addons/fxos_#SLASHED_VERSION#_simulator-#OS#.xpi");
 Services.prefs.setCharPref("devtools.webide.adbAddonURL", TEST_BASE + "addons/adbhelper-#OS#.xpi");
 Services.prefs.setCharPref("devtools.webide.adaptersAddonURL", TEST_BASE + "addons/fxdt-adapters-#OS#.xpi");
 Services.prefs.setCharPref("devtools.webide.templatesURL", TEST_BASE + "templates.json");
 Services.prefs.setCharPref("devtools.devices.url", TEST_BASE + "browser_devices.json");
 
 SimpleTest.registerCleanupFunction(() => {
+  gDevTools.testing = false;
   Services.prefs.clearUserPref("devtools.webide.enabled");
   Services.prefs.clearUserPref("devtools.webide.enableLocalRuntime");
   Services.prefs.clearUserPref("devtools.webide.autoinstallADBHelper");
   Services.prefs.clearUserPref("devtools.webide.autoinstallFxdtAdapters");
   Services.prefs.clearUserPref("devtools.webide.sidebars");
   Services.prefs.clearUserPref("devtools.webide.busyTimeout");
   Services.prefs.clearUserPref("devtools.webide.lastSelectedProject");
   Services.prefs.clearUserPref("devtools.webide.lastConnectedRuntime");
diff --git a/toolkit/devtools/server/actors/profiler.js b/toolkit/devtools/server/actors/profiler.js
index 8720ae1..fec1ad2 100644
--- a/toolkit/devtools/server/actors/profiler.js
+++ b/toolkit/devtools/server/actors/profiler.js
@@ -13,19 +13,16 @@ let DEFAULT_PROFILER_FEATURES = ["js"];
 let DEFAULT_PROFILER_THREADFILTERS = ["GeckoMain"];
 
 /**
  * The nsIProfiler is target agnostic and interacts with the whole platform.
  * Therefore, special care needs to be given to make sure different actor
  * consumers (i.e. "toolboxes") don't interfere with each other.
  */
 let gProfilerConsumers = 0;
-let gProfilingStartTime = -1;
-Services.obs.addObserver(() => gProfilingStartTime = Date.now(), "profiler-started", false);
-Services.obs.addObserver(() => gProfilingStartTime = -1, "profiler-stopped", false);
 
 loader.lazyGetter(this, "nsIProfilerModule", () => {
   return Cc["@mozilla.org/tools/profiler;1"].getService(Ci.nsIProfiler);
 });
 
 /**
  * The profiler actor provides remote access to the built-in nsIProfiler module.
  */
@@ -92,17 +89,17 @@ ProfilerActor.prototype = {
   },
 
   /**
    * Verifies whether or not the nsIProfiler module has started.
    * If already active, the current time is also returned.
    */
   onIsActive: function() {
     let isActive = nsIProfilerModule.IsActive();
-    let elapsedTime = isActive ? getElapsedTime() : undefined;
+    let elapsedTime = isActive ? nsIProfilerModule.getElapsedTime() : undefined;
     return { isActive: isActive, currentTime: elapsedTime };
   },
 
   /**
    * Returns a stringified JSON object that describes the shared libraries
    * which are currently loaded into our process. Can be called while the
    * profiler is stopped.
    */
@@ -128,20 +125,28 @@ ProfilerActor.prototype = {
    *         category: number
    *       } ... ],
    *       name: string
    *       responsiveness: number
    *       time: number
    *     } ... ]
    *   } ... ]
    * }
+   *
+   *
+   * @param number startTime
+   *        Since the circular buffer will only grow as long as the profiler lives,
+   *        the buffer can contain unwanted samples. Pass in a `startTime` to only retrieve
+   *        samples that took place after the `startTime`, with 0 being when the profiler
+   *        just started.
    */
-  onGetProfile: function() {
-    let profile = nsIProfilerModule.getProfileData();
-    return { profile: profile, currentTime: getElapsedTime() };
+  onGetProfile: function(request) {
+    let startTime = request.startTime || 0;
+    let profile = nsIProfilerModule.getProfileData(startTime);
+    return { profile: profile, currentTime: nsIProfilerModule.getElapsedTime() };
   },
 
   /**
    * Registers for certain event notifications.
    * Currently supported events:
    *   - "console-api-profiler"
    *   - "profiler-started"
    *   - "profiler-stopped"
@@ -224,95 +229,65 @@ ProfilerActor.prototype = {
    * creates an appropriate response sent over the protocol.
    * @param object subject
    * @param object data
    * @return object
    */
   _handleConsoleEvent: function(subject, data) {
     // An optional label may be specified when calling `console.profile`.
     // If that's the case, stringify it and send it over with the response.
-    let args = subject.arguments;
+    let { action, arguments: args } = subject;
     let profileLabel = args.length > 0 ? args[0] + "" : undefined;
 
     // If the event was generated from `console.profile` or `console.profileEnd`
     // we need to start the profiler right away and then just notify the client.
     // Otherwise, we'll lose precious samples.
 
-    if (subject.action == "profile") {
+    if (action === "profile" || action === "profileEnd") {
       let { isActive, currentTime } = this.onIsActive();
 
       // Start the profiler only if it wasn't already active. Otherwise, any
       // samples that might have been accumulated so far will be discarded.
-      if (!isActive) {
+      if (!isActive && action === "profile") {
         this.onStartProfiler();
         return {
           profileLabel: profileLabel,
           currentTime: 0
         };
       }
+      // Otherwise, if inactive and a call to profile end, send
+      // an empty object because we can't do anything with this.
+      else if (!isActive) {
+        return {};
+      }
+
+      // Otherwise, the profiler is already active, so just send
+      // to the front the current time, label, and the notification
+      // adds the action as well.
       return {
         profileLabel: profileLabel,
         currentTime: currentTime
       };
     }
-
-    if (subject.action == "profileEnd") {
-      let details = this.onGetProfile();
-      details.profileLabel = profileLabel;
-      return details;
-    }
   }
 };
 
 exports.ProfilerActor = ProfilerActor;
 
 /**
  * JSON.stringify callback used in ProfilerActor.prototype.observe.
  */
 function cycleBreaker(key, value) {
   if (key == "wrappedJSObject") {
     return undefined;
   }
   return value;
 }
 
 /**
- * Gets the time elapsed since the profiler was last started.
- * @return number
- */
-function getElapsedTime() {
-  // Assign `gProfilingStartTime` now if no client of this actor has actually
-  // started it yet, but the built-in profiler module is somehow already active
-  // (it could happen if the MOZ_PROFILER_STARTUP environment variable is set,
-  // or the Gecko Profiler add-on is installed and isn't using this actor).
-  // Otherwise, the returned value is bogus and messes up the samples filtering.
-  if (gProfilingStartTime == -1) {
-    let profile = nsIProfilerModule.getProfileData();
-    let lastSampleTime = findOldestSampleTime(profile);
-    gProfilingStartTime = Date.now() - lastSampleTime;
-  }
-  return Date.now() - gProfilingStartTime;
-}
-
-/**
- * Finds the oldest sample time in the provided profile.
- * @param object profile
- * @return number
- */
-function findOldestSampleTime(profile) {
-  let firstThreadSamples = profile.threads[0].samples;
-
-  for (let i = firstThreadSamples.length - 1; i >= 0; i--) {
-    if ("time" in firstThreadSamples[i]) {
-      return firstThreadSamples[i].time;
-    }
-  }
-}
-
-/**
  * Asserts the value sanity of `gProfilerConsumers`.
  */
 function checkProfilerConsumers() {
   if (gProfilerConsumers < 0) {
     let msg = "Somehow the number of started profilers is now negative.";
     DevToolsUtils.reportException("ProfilerActor", msg);
   }
 }
diff --git a/toolkit/devtools/server/actors/root.js b/toolkit/devtools/server/actors/root.js
index 4cc53c3..f1a971d 100644
--- a/toolkit/devtools/server/actors/root.js
+++ b/toolkit/devtools/server/actors/root.js
@@ -161,16 +161,19 @@ RootActor.prototype = {
     // if allowChromeProcess is true, you can fetch a ChromeActor instance
     // to debug chrome and any non-content ressource via getProcess request
     // if allocChromeProcess is defined, but not true, it means that root actor
     // no longer expose tab actors, but also that getProcess forbids
     // exposing actors for security reasons
     get allowChromeProcess() {
       return DebuggerServer.allowChromeProcess;
     },
+    // Whether or not `getProfile()` supports specifying a `startTime`
+    // and `endTime` to filter out samples. Fx40+
+    profilerDataFilterable: true,
   },
 
   /**
    * Return a 'hello' packet as specified by the Remote Debugging Protocol.
    */
   sayHello: function() {
     return {
       from: this.actorID,
diff --git a/toolkit/devtools/server/tests/unit/test_profiler_data.js b/toolkit/devtools/server/tests/unit/test_profiler_data.js
index 638e95e..e065e3b 100644
--- a/toolkit/devtools/server/tests/unit/test_profiler_data.js
+++ b/toolkit/devtools/server/tests/unit/test_profiler_data.js
@@ -11,65 +11,65 @@
 const Profiler = Cc["@mozilla.org/tools/profiler;1"].getService(Ci.nsIProfiler);
 const INITIAL_WAIT_TIME = 100; // ms
 const MAX_WAIT_TIME = 20000; // ms
 
 function run_test()
 {
   get_chrome_actors((client, form) => {
     let actor = form.profilerActor;
-    activate_profiler(client, actor, () => {
-      test_data(client, actor, () => {
+    activate_profiler(client, actor, startTime => {
+      test_data(client, actor, startTime, () => {
         deactivate_profiler(client, actor, () => {
           client.close(do_test_finished);
         })
       });
     });
   })
 
   do_test_pending();
 }
 
 function activate_profiler(client, actor, callback)
 {
   client.request({ to: actor, type: "startProfiler" }, response => {
     do_check_true(response.started);
     client.request({ to: actor, type: "isActive" }, response => {
       do_check_true(response.isActive);
-      callback();
+      callback(response.currentTime);
     });
   });
 }
 
 function deactivate_profiler(client, actor, callback)
 {
   client.request({ to: actor, type: "stopProfiler" }, response => {
     do_check_false(response.started);
     client.request({ to: actor, type: "isActive" }, response => {
       do_check_false(response.isActive);
       callback();
     });
   });
 }
 
-function test_data(client, actor, callback)
+function test_data(client, actor, startTime, callback)
 {
   function attempt(delay)
   {
     // No idea why, but Components.stack.sourceLine returns null.
     let funcLine = Components.stack.lineNumber - 3;
 
     // Spin for the requested time, then take a sample.
     let start = Date.now();
     let stack;
     do_print("Attempt: delay = " + delay);
     while (Date.now() - start < delay) { stack = Components.stack; }
     do_print("Attempt: finished waiting.");
 
-    client.request({ to: actor, type: "getProfile" }, response => {
+    client.request({ to: actor, type: "getProfile", startTime  }, response => {
       // Any valid getProfile response should have the following top
       // level structure.
       do_check_eq(typeof response.profile, "object");
       do_check_eq(typeof response.profile.meta, "object");
       do_check_eq(typeof response.profile.meta.platform, "string");
       do_check_eq(typeof response.profile.threads, "object");
       do_check_eq(typeof response.profile.threads[0], "object");
       do_check_eq(typeof response.profile.threads[0].samples, "object");
-- 
2.2.1


From 6f74ef655832b9bd9488eb48fb00b58e71898566 Mon Sep 17 00:00:00 2001
From: Jordan Santell <jsantell@gmail.com>
Date: Fri, 24 Apr 2015 13:29:16 -0700
Subject: [PATCH 2/2] backend

---
 tools/profiler/GeckoProfiler.h     |  7 +++--
 tools/profiler/GeckoProfilerFunc.h |  4 +--
 tools/profiler/GeckoProfilerImpl.h |  8 ++---
 tools/profiler/ProfileEntry.cpp    | 60 +++++++++++++++++++++++++++++---------
 tools/profiler/ProfileEntry.h      | 12 ++++----
 tools/profiler/ProfilerMarkers.cpp |  2 +-
 tools/profiler/PseudoStack.h       |  2 +-
 tools/profiler/TableTicker.cpp     | 22 +++++++-------
 tools/profiler/TableTicker.h       |  6 ++--
 tools/profiler/nsIProfiler.idl     | 22 ++++++++++++--
 tools/profiler/nsProfiler.cpp      | 18 ++++++++----
 tools/profiler/platform.cpp        | 10 +++----
 12 files changed, 116 insertions(+), 57 deletions(-)

diff --git a/tools/profiler/GeckoProfiler.h b/tools/profiler/GeckoProfiler.h
index 6ad624f..db85bfd 100644
--- a/tools/profiler/GeckoProfiler.h
+++ b/tools/profiler/GeckoProfiler.h
@@ -153,20 +153,23 @@ static inline bool profiler_feature_active(const char*) { return false; }
 
 // Internal-only. Used by the event tracer.
 static inline void profiler_responsiveness(const mozilla::TimeStamp& aTime) {}
 
 // Internal-only.
 static inline void profiler_set_frame_number(int frameNumber) {}
 
 // Get the profile encoded as a JSON string.
-static inline char* profiler_get_profile() { return nullptr; }
+static inline char* profiler_get_profile(float aSinceTime = 0) { return nullptr; }
 
 // Get the profile encoded as a JSON object.
-static inline JSObject* profiler_get_profile_jsobject(JSContext* aCx) { return nullptr; }
+static inline JSObject* profiler_get_profile_jsobject(JSContext* aCx,
+                                                      float aSinceTime = 0) {
+  return nullptr;
+}
 
 // Get the profile and write it into a file
 static inline void profiler_save_profile_to_file(char* aFilename) { }
 
 // Get the features supported by the profiler that are accepted by profiler_init.
 // Returns a null terminated char* array.
 static inline char** profiler_get_features() { return nullptr; }
 
diff --git a/tools/profiler/GeckoProfilerFunc.h b/tools/profiler/GeckoProfilerFunc.h
index 5f444b8..03ecbc8 100644
--- a/tools/profiler/GeckoProfilerFunc.h
+++ b/tools/profiler/GeckoProfilerFunc.h
@@ -48,19 +48,19 @@ bool mozilla_sampler_feature_active(const char* aName);
 void mozilla_sampler_responsiveness(const mozilla::TimeStamp& time);
 
 void mozilla_sampler_frame_number(int frameNumber);
 
 const double* mozilla_sampler_get_responsiveness();
 
 void mozilla_sampler_save();
 
-char* mozilla_sampler_get_profile();
+char* mozilla_sampler_get_profile(float aSinceTime);
 
-JSObject *mozilla_sampler_get_profile_data(JSContext *aCx);
+JSObject *mozilla_sampler_get_profile_data(JSContext *aCx, float aSinceTime);
 
 // Make this function easily callable from a debugger in a build without
 // debugging information (work around http://llvm.org/bugs/show_bug.cgi?id=22211)
 extern "C" {
   void mozilla_sampler_save_profile_to_file(const char* aFilename);
 }
 
 const char** mozilla_sampler_get_features();
diff --git a/tools/profiler/GeckoProfilerImpl.h b/tools/profiler/GeckoProfilerImpl.h
index fa358f8..62f3b9c 100644
--- a/tools/profiler/GeckoProfilerImpl.h
+++ b/tools/profiler/GeckoProfilerImpl.h
@@ -139,25 +139,25 @@ void profiler_responsiveness(const mozilla::TimeStamp& aTime)
 
 static inline
 void profiler_set_frame_number(int frameNumber)
 {
   return mozilla_sampler_frame_number(frameNumber);
 }
 
 static inline
-char* profiler_get_profile()
+char* profiler_get_profile(float aSinceTime = 0)
 {
-  return mozilla_sampler_get_profile();
+  return mozilla_sampler_get_profile(aSinceTime);
 }
 
 static inline
-JSObject* profiler_get_profile_jsobject(JSContext* aCx)
+JSObject* profiler_get_profile_jsobject(JSContext* aCx, float aSinceTime = 0)
 {
-  return mozilla_sampler_get_profile_data(aCx);
+  return mozilla_sampler_get_profile_data(aCx, aSinceTime);
 }
 
 static inline
 void profiler_save_profile_to_file(const char* aFilename)
 {
   return mozilla_sampler_save_profile_to_file(aFilename);
 }
 
diff --git a/tools/profiler/ProfileEntry.cpp b/tools/profiler/ProfileEntry.cpp
index d94247d..a0e0e22 100644
--- a/tools/profiler/ProfileEntry.cpp
+++ b/tools/profiler/ProfileEntry.cpp
@@ -388,28 +388,40 @@ void UniqueJITOptimizations::stream(JSStreamWriter& b, JSRuntime* rt)
     unsigned line, column;
     line = JS_PCToLineNumber(script, pc, &column);
     b.NameValue("line", line);
     b.NameValue("column", column);
     b.EndObject();
   }
 }
 
-void ProfileBuffer::StreamSamplesToJSObject(JSStreamWriter& b, int aThreadId, JSRuntime* rt,
+void ProfileBuffer::StreamSamplesToJSObject(JSStreamWriter& b, int aThreadId,
+                                            float aSinceTime, JSRuntime* rt,
                                             UniqueJITOptimizations& aUniqueOpts)
 {
   bool sample = false;
   int readPos = mReadPos;
   int currentThreadID = -1;
+  float currentTime = 0;
+  bool hasCurrentTime = false;
   while (readPos != mWritePos) {
     ProfileEntry entry = mEntries[readPos];
     if (entry.mTagName == 'T') {
       currentThreadID = entry.mTagInt;
+      hasCurrentTime = false;
+      int readAheadPos = (readPos + 1) % mEntrySize;
+      if (readAheadPos != mWritePos) {
+        ProfileEntry readAheadEntry = mEntries[readAheadPos];
+        if (readAheadEntry.mTagName == 't') {
+          currentTime = readAheadEntry.mTagFloat;
+          hasCurrentTime = true;
+        }
+      }
     }
-    if (currentThreadID == aThreadId) {
+    if (currentThreadID == aThreadId && (!hasCurrentTime || currentTime >= aSinceTime)) {
       switch (entry.mTagName) {
         case 'r':
           {
             if (sample) {
               b.NameValue("responsiveness", entry.mTagFloat);
             }
           }
           break;
@@ -438,32 +450,42 @@ void ProfileBuffer::StreamSamplesToJSObject(JSStreamWriter& b, int aThreadId, JS
           {
             if (sample) {
               b.NameValue("frameNumber", entry.mTagInt);
             }
           }
           break;
         case 't':
           {
-            if (sample) {
+            // FIXMEshu: this case is only needed because filtering by
+            // aSinceTime is broken if the unwinder thread is used, due to
+            // its placement of 't' tags.
+            //
+            // UnwinderTick is slated for removal in bug 1141712. Remove
+            // this case once it lands.
+            if (sample && (currentTime != entry.mTagFloat)) {
               b.NameValue("time", entry.mTagFloat);
             }
           }
           break;
         case 's':
           {
             // end the previous sample if there was one
             if (sample) {
               b.EndObject();
             }
             // begin the next sample
             b.BeginObject();
 
             sample = true;
 
+            if (hasCurrentTime) {
+              b.NameValue("time", currentTime);
+            }
+
             // Seek forward through the entire sample, looking for frames
             // this is an easier approach to reason about than adding more
             // control variables and cases to the loop that goes through the buffer once
             b.Name("frames");
             b.BeginArray();
 
               b.BeginObject();
                 b.NameValue("location", "(root)");
@@ -530,26 +552,29 @@ void ProfileBuffer::StreamSamplesToJSObject(JSStreamWriter& b, int aThreadId, JS
     }
     readPos = (readPos + 1) % mEntrySize;
   }
   if (sample) {
     b.EndObject();
   }
 }
 
-void ProfileBuffer::StreamMarkersToJSObject(JSStreamWriter& b, int aThreadId)
+void ProfileBuffer::StreamMarkersToJSObject(JSStreamWriter& b, int aThreadId, float aSinceTime)
 {
   int readPos = mReadPos;
   int currentThreadID = -1;
   while (readPos != mWritePos) {
     ProfileEntry entry = mEntries[readPos];
     if (entry.mTagName == 'T') {
       currentThreadID = entry.mTagInt;
     } else if (currentThreadID == aThreadId && entry.mTagName == 'm') {
-      entry.getMarker()->StreamJSObject(b);
+      const ProfilerMarker* marker = entry.getMarker();
+      if (marker->GetTime() >= aSinceTime) {
+        marker->StreamJSObject(b);
+      }
     }
     readPos = (readPos + 1) % mEntrySize;
   }
 }
 
 int ProfileBuffer::FindLastSampleOfThread(int aThreadId)
 {
   // We search backwards from mWritePos-1 to mReadPos.
@@ -645,23 +670,23 @@ void ThreadProfile::addStoredMarker(ProfilerMarker *aStoredMarker) {
   mBuffer->addStoredMarker(aStoredMarker);
 }
 
 void ThreadProfile::IterateTags(IterateTagsCallback aCallback)
 {
   mBuffer->IterateTagsForThread(aCallback, mThreadId);
 }
 
-void ThreadProfile::ToStreamAsJSON(std::ostream& stream)
+void ThreadProfile::ToStreamAsJSON(std::ostream& stream, float aSinceTime)
 {
   JSStreamWriter b(stream);
-  StreamJSObject(b);
+  StreamJSObject(b, aSinceTime);
 }
 
-void ThreadProfile::StreamJSObject(JSStreamWriter& b)
+void ThreadProfile::StreamJSObject(JSStreamWriter& b, float aSinceTime)
 {
   b.BeginObject();
     // Thread meta data
     if (XRE_GetProcessType() == GeckoProcessType_Plugin) {
       // TODO Add the proper plugin name
       b.NameValue("name", "Plugin");
     } else if (XRE_GetProcessType() == GeckoProcessType_Content) {
       // This isn't going to really help once we have multiple content
@@ -672,46 +697,53 @@ void ThreadProfile::StreamJSObject(JSStreamWriter& b)
     }
     b.NameValue("tid", static_cast<int>(mThreadId));
 
     UniqueJITOptimizations uniqueOpts;
 
     b.Name("samples");
     b.BeginArray();
       if (!mSavedStreamedSamples.empty()) {
+        // We would only have saved streamed samples during shutdown
+        // streaming, which cares about dumping the entire buffer, and thus
+        // should have passed in 0 for aSinceTime.
+        MOZ_ASSERT(aSinceTime == 0);
         b.SpliceArrayElements(mSavedStreamedSamples.c_str());
         mSavedStreamedSamples.clear();
       }
-      mBuffer->StreamSamplesToJSObject(b, mThreadId, mPseudoStack->mRuntime, uniqueOpts);
+      mBuffer->StreamSamplesToJSObject(b, mThreadId, aSinceTime, mPseudoStack->mRuntime,
+                                       uniqueOpts);
     b.EndArray();
 
     // Having saved streamed optimizations implies the JS engine has
     // shutdown. If the JS engine is gone, we shouldn't have any new JS
     // samples, and thus no optimizations.
     if (!mSavedStreamedOptimizations.empty()) {
+      MOZ_ASSERT(aSinceTime == 0);
       MOZ_ASSERT(uniqueOpts.empty());
       b.Name("optimizations");
       b.BeginArray();
         b.SpliceArrayElements(mSavedStreamedOptimizations.c_str());
         mSavedStreamedOptimizations.clear();
       b.EndArray();
     } else if (!uniqueOpts.empty()) {
       b.Name("optimizations");
       b.BeginArray();
         uniqueOpts.stream(b, mPseudoStack->mRuntime);
       b.EndArray();
     }
 
     b.Name("markers");
     b.BeginArray();
       if (!mSavedStreamedMarkers.empty()) {
+        MOZ_ASSERT(aSinceTime == 0);
         b.SpliceArrayElements(mSavedStreamedMarkers.c_str());
         mSavedStreamedMarkers.clear();
       }
-      mBuffer->StreamMarkersToJSObject(b, mThreadId);
+      mBuffer->StreamMarkersToJSObject(b, mThreadId, aSinceTime);
     b.EndArray();
   b.EndObject();
 }
 
 void ThreadProfile::FlushSamplesAndMarkers()
 {
   // This function is used to serialize the current buffer just before
   // JSRuntime destruction.
@@ -720,17 +752,17 @@ void ThreadProfile::FlushSamplesAndMarkers()
   // Unlike StreamJSObject, do not surround the samples in brackets by calling
   // b.{Begin,End}Array. The result string will be a comma-separated list of
   // JSON object literals that will prepended by StreamJSObject into an
   // existing array.
   std::stringstream ss;
   JSStreamWriter b(ss);
   UniqueJITOptimizations uniqueOpts;
   b.BeginBareList();
-    mBuffer->StreamSamplesToJSObject(b, mThreadId, mPseudoStack->mRuntime, uniqueOpts);
+  mBuffer->StreamSamplesToJSObject(b, mThreadId, 0, mPseudoStack->mRuntime, uniqueOpts);
   b.EndBareList();
   mSavedStreamedSamples = ss.str();
 
   // Reuse the stringstream.
   ss.str("");
   ss.clear();
 
   if (!uniqueOpts.empty()) {
@@ -740,34 +772,34 @@ void ThreadProfile::FlushSamplesAndMarkers()
     mSavedStreamedOptimizations = ss.str();
   }
 
   // Reuse the stringstream.
   ss.str("");
   ss.clear();
 
   b.BeginBareList();
-    mBuffer->StreamMarkersToJSObject(b, mThreadId);
+    mBuffer->StreamMarkersToJSObject(b, mThreadId, 0);
   b.EndBareList();
   mSavedStreamedMarkers = ss.str();
 
   // Reset the buffer. Attempting to symbolicate JS samples after mRuntime has
   // gone away will crash.
   mBuffer->reset();
 }
 
-JSObject* ThreadProfile::ToJSObject(JSContext *aCx)
+JSObject* ThreadProfile::ToJSObject(JSContext *aCx, float aSinceTime)
 {
   JS::RootedValue val(aCx);
   std::stringstream ss;
   {
     // Define a scope to prevent a moving GC during ~JSStreamWriter from
     // trashing the return value.
     JSStreamWriter b(ss);
-    StreamJSObject(b);
+    StreamJSObject(b, aSinceTime);
     NS_ConvertUTF8toUTF16 js_string(nsDependentCString(ss.str().c_str()));
     JS_ParseJSON(aCx, static_cast<const char16_t*>(js_string.get()),
                  js_string.Length(), &val);
   }
   return &val.toObject();
 }
 
 PseudoStack* ThreadProfile::GetPseudoStack()
diff --git a/tools/profiler/ProfileEntry.h b/tools/profiler/ProfileEntry.h
index d21a20c..95182d9 100644
--- a/tools/profiler/ProfileEntry.h
+++ b/tools/profiler/ProfileEntry.h
@@ -97,19 +97,19 @@ class UniqueJITOptimizations {
 class ProfileBuffer {
 public:
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ProfileBuffer)
 
   explicit ProfileBuffer(int aEntrySize);
 
   void addTag(const ProfileEntry& aTag);
   void IterateTagsForThread(IterateTagsCallback aCallback, int aThreadId);
-  void StreamSamplesToJSObject(JSStreamWriter& b, int aThreadId, JSRuntime* rt,
-                               UniqueJITOptimizations& aUniqueOpts);
-  void StreamMarkersToJSObject(JSStreamWriter& b, int aThreadId);
+  void StreamSamplesToJSObject(JSStreamWriter& b, int aThreadId, float aSinceTime,
+                               JSRuntime* rt, UniqueJITOptimizations& aUniqueOpts);
+  void StreamMarkersToJSObject(JSStreamWriter& b, int aThreadId, float aSinceTime);
   void DuplicateLastSample(int aThreadId);
 
   void addStoredMarker(ProfilerMarker* aStoredMarker);
 
   // The following two methods are not signal safe! They delete markers.
   void deleteExpiredStoredMarkers();
   void reset();
 
@@ -150,21 +150,21 @@ public:
   /**
    * Track a marker which has been inserted into the ThreadProfile.
    * This marker can safely be deleted once the generation has
    * expired.
    */
   void addStoredMarker(ProfilerMarker *aStoredMarker);
 
   void IterateTags(IterateTagsCallback aCallback);
-  void ToStreamAsJSON(std::ostream& stream);
-  JSObject *ToJSObject(JSContext *aCx);
+  void ToStreamAsJSON(std::ostream& stream, float aSinceTime = 0);
+  JSObject *ToJSObject(JSContext *aCx, float aSinceTime = 0);
   PseudoStack* GetPseudoStack();
   mozilla::Mutex* GetMutex();
-  void StreamJSObject(JSStreamWriter& b);
+  void StreamJSObject(JSStreamWriter& b, float aSinceTime = 0);
 
   /**
    * Call this method when the JS entries inside the buffer are about to
    * become invalid, i.e., just before JS shutdown.
    */
   void FlushSamplesAndMarkers();
 
   void BeginUnwind();
diff --git a/tools/profiler/ProfilerMarkers.cpp b/tools/profiler/ProfilerMarkers.cpp
index 21d9093..97cf4b4 100644
--- a/tools/profiler/ProfilerMarkers.cpp
+++ b/tools/profiler/ProfilerMarkers.cpp
@@ -25,17 +25,17 @@ ProfilerMarkerPayload::ProfilerMarkerPayload(const mozilla::TimeStamp& aStartTim
 
 ProfilerMarkerPayload::~ProfilerMarkerPayload()
 {
   profiler_free_backtrace(mStack);
 }
 
 void
 ProfilerMarkerPayload::streamCommonProps(const char* aMarkerType,
-                                          JSStreamWriter& b)
+                                         JSStreamWriter& b)
 {
   MOZ_ASSERT(aMarkerType);
   b.NameValue("type", aMarkerType);
   if (!mStartTime.IsNull()) {
     b.NameValue("startTime", profiler_time(mStartTime));
   }
   if (!mEndTime.IsNull()) {
     b.NameValue("endTime", profiler_time(mEndTime));
diff --git a/tools/profiler/PseudoStack.h b/tools/profiler/PseudoStack.h
index 392842b..bc96af6 100644
--- a/tools/profiler/PseudoStack.h
+++ b/tools/profiler/PseudoStack.h
@@ -92,17 +92,17 @@ public:
   StreamJSObject(JSStreamWriter& b) const;
 
   void SetGeneration(uint32_t aGenID);
 
   bool HasExpired(uint32_t aGenID) const {
     return mGenID + 2 <= aGenID;
   }
 
-  float GetTime();
+  float GetTime() const;
 
 private:
   char* mMarkerName;
   ProfilerMarkerPayload* mPayload;
   ProfilerMarker* mNext;
   float mTime;
   uint32_t mGenID;
 };
diff --git a/tools/profiler/TableTicker.cpp b/tools/profiler/TableTicker.cpp
index f68c14b..6fc99b3 100644
--- a/tools/profiler/TableTicker.cpp
+++ b/tools/profiler/TableTicker.cpp
@@ -213,31 +213,31 @@ void TableTicker::StreamMetaJSCustomObject(JSStreamWriter& b)
       res = appInfo->GetName(string);
       if (!NS_FAILED(res))
         b.NameValue("product", string.Data());
     }
 
   b.EndObject();
 }
 
-void TableTicker::ToStreamAsJSON(std::ostream& stream)
+void TableTicker::ToStreamAsJSON(std::ostream& stream, float aSinceTime)
 {
   JSStreamWriter b(stream);
-  StreamJSObject(b);
+  StreamJSObject(b, aSinceTime);
 }
 
-JSObject* TableTicker::ToJSObject(JSContext *aCx)
+JSObject* TableTicker::ToJSObject(JSContext *aCx, float aSinceTime)
 {
   JS::RootedValue val(aCx);
   std::stringstream ss;
   {
     // Define a scope to prevent a moving GC during ~JSStreamWriter from
     // trashing the return value.
     JSStreamWriter b(ss);
-    StreamJSObject(b);
+    StreamJSObject(b, aSinceTime);
     NS_ConvertUTF8toUTF16 js_string(nsDependentCString(ss.str().c_str()));
     JS_ParseJSON(aCx, static_cast<const char16_t*>(js_string.get()),
                  js_string.Length(), &val);
   }
   return &val.toObject();
 }
 
 struct SubprocessClosure {
@@ -311,17 +311,17 @@ void BuildJavaThreadJSObject(JSStreamWriter& b)
       }
 
     b.EndArray();
 
   b.EndObject();
 }
 #endif
 
-void TableTicker::StreamJSObject(JSStreamWriter& b)
+void TableTicker::StreamJSObject(JSStreamWriter& b, float aSinceTime)
 {
   b.BeginObject();
     // Put shared library info
     b.NameValue("libs", GetSharedLibraryInfoString().c_str());
 
     // Put meta data
     b.Name("meta");
     StreamMetaJSCustomObject(b);
@@ -346,17 +346,17 @@ void TableTicker::StreamJSObject(JSStreamWriter& b)
           if (!sRegisteredThreads->at(i)->Profile())
             continue;
 
           // Note that we intentionally include ThreadProfile which
           // have been marked for pending delete.
 
           MutexAutoLock lock(*sRegisteredThreads->at(i)->Profile()->GetMutex());
 
-          sRegisteredThreads->at(i)->Profile()->StreamJSObject(b);
+          sRegisteredThreads->at(i)->Profile()->StreamJSObject(b, aSinceTime);
         }
       }
 
       if (Sampler::CanNotifyObservers()) {
         // Send a event asking any subprocesses (plugins) to
         // give us their information
         SubprocessClosure closure(&b);
         nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
@@ -974,16 +974,21 @@ void TableTicker::Tick(TickSample* sample)
 }
 
 void TableTicker::InplaceTick(TickSample* sample)
 {
   ThreadProfile& currThreadProfile = *sample->threadProfile;
 
   currThreadProfile.addTag(ProfileEntry('T', currThreadProfile.ThreadId()));
 
+  if (sample) {
+    mozilla::TimeDuration delta = sample->timestamp - sStartTime;
+    currThreadProfile.addTag(ProfileEntry('t', static_cast<float>(delta.ToMilliseconds())));
+  }
+
   PseudoStack* stack = currThreadProfile.GetPseudoStack();
 
 #if defined(USE_NS_STACKWALK) || defined(USE_EHABI_STACKWALK) || \
     defined(USE_LUL_STACKWALK)
   if (mUseStackWalk) {
     doNativeBacktrace(currThreadProfile, sample);
   } else {
     doSampleStackTrace(currThreadProfile, sample, mAddLeafAddresses);
@@ -1003,21 +1008,16 @@ void TableTicker::InplaceTick(TickSample* sample)
     }
   }
 
   if (sample && currThreadProfile.GetThreadResponsiveness()->HasData()) {
     mozilla::TimeDuration delta = currThreadProfile.GetThreadResponsiveness()->GetUnresponsiveDuration(sample->timestamp);
     currThreadProfile.addTag(ProfileEntry('r', static_cast<float>(delta.ToMilliseconds())));
   }
 
-  if (sample) {
-    mozilla::TimeDuration delta = sample->timestamp - sStartTime;
-    currThreadProfile.addTag(ProfileEntry('t', static_cast<float>(delta.ToMilliseconds())));
-  }
-
   // rssMemory is equal to 0 when we are not recording.
   if (sample && sample->rssMemory != 0) {
     currThreadProfile.addTag(ProfileEntry('R', static_cast<float>(sample->rssMemory)));
   }
 
   // ussMemory is equal to 0 when we are not recording.
   if (sample && sample->ussMemory != 0) {
     currThreadProfile.addTag(ProfileEntry('U', static_cast<float>(sample->ussMemory)));
diff --git a/tools/profiler/TableTicker.h b/tools/profiler/TableTicker.h
index 9bb86f8..0cadd3e 100644
--- a/tools/profiler/TableTicker.h
+++ b/tools/profiler/TableTicker.h
@@ -187,18 +187,18 @@ class TableTicker: public Sampler {
           break;
         }
       }
     }
 
     return mPrimaryThreadProfile;
   }
 
-  void ToStreamAsJSON(std::ostream& stream);
-  virtual JSObject *ToJSObject(JSContext *aCx);
+  void ToStreamAsJSON(std::ostream& stream, float aSinceTime = 0);
+  virtual JSObject *ToJSObject(JSContext *aCx, float aSinceTime = 0);
   void StreamMetaJSCustomObject(JSStreamWriter& b);
   void StreamTaskTracer(JSStreamWriter& b);
   void FlushOnJSShutdown(JSRuntime* aRuntime);
   bool ProfileJS() const { return mProfileJS; }
   bool ProfileJava() const { return mProfileJava; }
   bool ProfileGPU() const { return mProfileGPU; }
   bool ProfilePower() const { return mProfilePower; }
   bool ProfileThreads() const override { return mProfileThreads; }
@@ -214,17 +214,17 @@ class TableTicker: public Sampler {
 
 protected:
   // Called within a signal. This function must be reentrant
   virtual void InplaceTick(TickSample* sample);
 
   // Not implemented on platforms which do not support backtracing
   void doNativeBacktrace(ThreadProfile &aProfile, TickSample* aSample);
 
-  void StreamJSObject(JSStreamWriter& b);
+  void StreamJSObject(JSStreamWriter& b, float aSinceTime);
 
   // This represent the application's main thread (SAMPLER_INIT)
   ThreadProfile* mPrimaryThreadProfile;
   nsRefPtr<ProfileBuffer> mBuffer;
   bool mSaveRequested;
   bool mAddLeafAddresses;
   bool mUseStackWalk;
   bool mProfileJS;
diff --git a/tools/profiler/nsIProfiler.idl b/tools/profiler/nsIProfiler.idl
index e4546ce..676b38d 100644
--- a/tools/profiler/nsIProfiler.idl
+++ b/tools/profiler/nsIProfiler.idl
@@ -7,39 +7,55 @@
 
 %{C++
 template<class T> class nsTArray;
 class nsCString;
 %}
 
 [ref] native StringArrayRef(const nsTArray<nsCString>);
 
-[scriptable, uuid(edd65f3f-c2a2-4217-a2e2-40347ba4a2b3)]
+[scriptable, uuid(9f3e7c97-abcf-425c-83fd-34d354eb95e8)]
 interface nsIProfiler : nsISupports
 {
   void StartProfiler(in uint32_t aEntries, in double aInterval,
                       [array, size_is(aFeatureCount)] in string aFeatures,
                       in uint32_t aFeatureCount,
                       [array, size_is(aFilterCount), optional] in string aThreadNameFilters,
                       [optional] in uint32_t aFilterCount);
   void StopProfiler();
   boolean IsPaused();
   void PauseSampling();
   void ResumeSampling();
   void AddMarker(in string aMarker);
-  string GetProfile();
+  /*
+   * Returns the JSON string of the profile. If aSinceTime is passed, only
+   * report samples taken at >= aSinceTime.
+   */
+  string GetProfile([optional] in float aSinceTime);
+
+  /*
+   * Returns a JS object of the profile. If aSinceTime is passed, only report
+   * samples taken at >= aSinceTime.
+   */
   [implicit_jscontext]
-  jsval getProfileData();
+  jsval getProfileData([optional] in float aSinceTime);
+
   boolean IsActive();
   void GetFeatures(out uint32_t aCount, [retval, array, size_is(aCount)] out string aFeatures);
 
   void GetBufferInfo(out uint32_t aCurrentPosition, out uint32_t aTotalSize,
                      out uint32_t aGeneration);
 
   /**
+   * Returns the elapsed time, in milliseconds, since the last StartProfiler call.
+   * Returns 0 if there is no active sampler.
+   */
+  float getElapsedTime();
+
+  /**
    * Returns a JSON string of an array of shared library objects.
    * Every object has three properties: start, end, and name.
    * start and end are integers describing the address range that the library
    * occupies in memory. name is the path of the library as a string.
    *
    * On Windows profiling builds, the shared library objects will have
    * additional pdbSignature and pdbAge properties for uniquely identifying
    * shared library versions for stack symbolication.
diff --git a/tools/profiler/nsProfiler.cpp b/tools/profiler/nsProfiler.cpp
index 9d127b4..56ee2fe 100644
--- a/tools/profiler/nsProfiler.cpp
+++ b/tools/profiler/nsProfiler.cpp
@@ -112,19 +112,19 @@ nsProfiler::ResumeSampling()
 NS_IMETHODIMP
 nsProfiler::AddMarker(const char *aMarker)
 {
   PROFILER_MARKER(aMarker);
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsProfiler::GetProfile(char **aProfile)
+nsProfiler::GetProfile(float aSinceTime, char **aProfile)
 {
-  char *profile = profiler_get_profile();
+  char *profile = profiler_get_profile(aSinceTime);
   if (profile) {
     size_t len = strlen(profile);
     char *profileStr = static_cast<char *>
                          (nsMemory::Clone(profile, (len + 1) * sizeof(char)));
     profileStr[len] = '\0';
     *aProfile = profileStr;
     free(profile);
   }
@@ -196,28 +196,36 @@ nsProfiler::GetSharedLibraryInformation(nsAString& aOutString)
 
 NS_IMETHODIMP
 nsProfiler::DumpProfileToFile(const char* aFilename)
 {
   profiler_save_profile_to_file(aFilename);
   return NS_OK;
 }
 
-NS_IMETHODIMP nsProfiler::GetProfileData(JSContext* aCx,
-                                         JS::MutableHandle<JS::Value> aResult)
+NS_IMETHODIMP
+nsProfiler::GetProfileData(float aSinceTime, JSContext* aCx,
+                           JS::MutableHandle<JS::Value> aResult)
 {
-  JS::RootedObject obj(aCx, profiler_get_profile_jsobject(aCx));
+  JS::RootedObject obj(aCx, profiler_get_profile_jsobject(aCx, aSinceTime));
   if (!obj) {
     return NS_ERROR_FAILURE;
   }
   aResult.setObject(*obj);
   return NS_OK;
 }
 
 NS_IMETHODIMP
+nsProfiler::GetElapsedTime(float* aElapsedTime)
+{
+  *aElapsedTime = static_cast<float>(profiler_time());
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 nsProfiler::IsActive(bool *aIsActive)
 {
   *aIsActive = profiler_is_active();
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsProfiler::GetFeatures(uint32_t *aCount, char ***aFeatures)
diff --git a/tools/profiler/platform.cpp b/tools/profiler/platform.cpp
index b4cb5bc..c61fe5f 100644
--- a/tools/profiler/platform.cpp
+++ b/tools/profiler/platform.cpp
@@ -196,17 +196,17 @@ ProfilerMarker::~ProfilerMarker() {
 }
 
 void
 ProfilerMarker::SetGeneration(uint32_t aGenID) {
   mGenID = aGenID;
 }
 
 float
-ProfilerMarker::GetTime() {
+ProfilerMarker::GetTime() const {
   return mTime;
 }
 
 void ProfilerMarker::StreamJSObject(JSStreamWriter& b) const {
   b.BeginObject();
     b.NameValue("name", GetMarkerName());
     // TODO: Store the callsite for this marker if available:
     // if have location data
@@ -546,37 +546,37 @@ void mozilla_sampler_save()
   }
 
   t->RequestSave();
   // We're on the main thread already so we don't
   // have to wait to handle the save request.
   t->HandleSaveRequest();
 }
 
-char* mozilla_sampler_get_profile()
+char* mozilla_sampler_get_profile(float aSinceTime)
 {
   TableTicker *t = tlsTicker.get();
   if (!t) {
     return nullptr;
   }
 
   std::stringstream stream;
-  t->ToStreamAsJSON(stream);
+  t->ToStreamAsJSON(stream, aSinceTime);
   char* profile = strdup(stream.str().c_str());
   return profile;
 }
 
-JSObject *mozilla_sampler_get_profile_data(JSContext *aCx)
+JSObject *mozilla_sampler_get_profile_data(JSContext *aCx, float aSinceTime)
 {
   TableTicker *t = tlsTicker.get();
   if (!t) {
     return nullptr;
   }
 
-  return t->ToJSObject(aCx);
+  return t->ToJSObject(aCx, aSinceTime);
 }
 
 void mozilla_sampler_save_profile_to_file(const char* aFilename)
 {
   TableTicker *t = tlsTicker.get();
   if (!t) {
     return;
   }
-- 
2.2.1

